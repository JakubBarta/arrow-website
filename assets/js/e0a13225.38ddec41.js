"use strict";(self.webpackChunkarrow_website=self.webpackChunkarrow_website||[]).push([[7435],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>m});var r=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=r.createContext({}),c=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},p=function(e){var t=c(e.components);return r.createElement(s.Provider,{value:t},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},h=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,s=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),u=c(n),h=a,m=u["".concat(s,".").concat(h)]||u[h]||d[h]||i;return n?r.createElement(m,l(l({ref:t},p),{},{components:n})):r.createElement(m,l({ref:t},p))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,l=new Array(i);l[0]=h;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o[u]="string"==typeof e?e:a,l[1]=o;for(var c=2;c<i;c++)l[c]=n[c];return r.createElement.apply(null,l)}return r.createElement.apply(null,n)}h.displayName="MDXCreateElement"},42693:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>d,frontMatter:()=>i,metadata:()=>o,toc:()=>c});var r=n(87462),a=(n(67294),n(3905));const i={sidebar_position:2},l="Retry and repeat",o={unversionedId:"learn/resilience/retry-and-repeat",id:"learn/resilience/retry-and-repeat",title:"Retry and repeat",description:"A common demand when working with actions is to retry or repeat them when",source:"@site/content/docs/learn/resilience/retry-and-repeat.md",sourceDirName:"learn/resilience",slug:"/learn/resilience/retry-and-repeat",permalink:"/learn/resilience/retry-and-repeat",draft:!1,editUrl:"https://github.com/arrow-kt/arrow-website/edit/main/content/docs/learn/resilience/retry-and-repeat.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"learnSidebar",previous:{title:"Introduction",permalink:"/learn/resilience/intro"},next:{title:"Circuit breaker",permalink:"/learn/resilience/circuitbreaker"}},s={},c=[{value:"Constructing a policy",id:"constructing-a-policy",level:2},{value:"Repeating an action",id:"repeating-an-action",level:2},{value:"Collecting values",id:"collecting-values",level:3},{value:"Until/while it produces a certain value",id:"untilwhile-it-produces-a-certain-value",level:3}],p={toc:c},u="wrapper";function d(e){let{components:t,...n}=e;return(0,a.kt)(u,(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"retry-and-repeat"},"Retry and repeat"),(0,a.kt)("p",null,"A common demand when working with actions is to retry or repeat them when\n(adverse) certain circumstances happen. Usually, the retrial or repetition does\nnot occur immediately; instead, it is done based on a policy. For instance, when\nfetching content from a network request, we may want to retry it when it fails\nusing an exponential backoff algorithm for a maximum of 15 seconds or 5\nattempts, whatever happens first."),(0,a.kt)("admonition",{title:"Additional context for this pattern",type:"info"},(0,a.kt)("p",{parentName:"admonition"},(0,a.kt)("a",{parentName:"p",href:"https://learn.microsoft.com/en-us/azure/architecture/patterns/retry"},"Retry pattern"),"\nin ",(0,a.kt)("em",{parentName:"p"},"Cloud Design Patterns"),".")),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://apidocs.arrow-kt.io/arrow-resilience/arrow.resilience/-schedule/index.html"},(0,a.kt)("inlineCode",{parentName:"a"},"Schedule")),"\nallows you to define and compose powerful yet simple policies. There are two\nsteps involved in using ",(0,a.kt)("inlineCode",{parentName:"p"},"Schedule"),"."),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"First, we need to ",(0,a.kt)("strong",{parentName:"li"},"construct")," a policy, which specifies the amount and the\ndelay in repetition."),(0,a.kt)("li",{parentName:"ol"},"Then we ",(0,a.kt)("strong",{parentName:"li"},"run")," this schedule with a specified action. There are two ways to do so:",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://apidocs.arrow-kt.io/arrow-resilience/arrow.resilience/retry.html"},(0,a.kt)("inlineCode",{parentName:"a"},"retry")),"\nexecutes the action once, and if it fails, it is reattempted based\non the scheduling policy. It stops when the action succeeds or when the policy\ndetermines it should not be reattempted again."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://apidocs.arrow-kt.io/arrow-resilience/arrow.resilience/-schedule/repeat.html"},(0,a.kt)("inlineCode",{parentName:"a"},"repeat")),"\nexecutes the action, and if it succeeds, keeps executing it again based on\nthe scheduling policy passed as an argument. It stops if the action\nfails or the policy determines it should not be executed again.\nIt returns the last internal state of the scheduling policy\nor the error that happened running the action.")))),(0,a.kt)("h2",{id:"constructing-a-policy"},"Constructing a policy"),(0,a.kt)("p",null,"Scheduling policies are constructed using the methods in ",(0,a.kt)("a",{parentName:"p",href:"https://apidocs.arrow-kt.io/arrow-resilience/arrow.resilience/-schedule/-companion/index.html"},(0,a.kt)("inlineCode",{parentName:"a"},"Schedule"),"'s\ncompanion object"),".\nSchedule policies also return values on each step, which can be used to\ntake decisions based on previous values."),(0,a.kt)("p",null,"One of the simplest policies is recurring ten times. This means that if we\ncall ",(0,a.kt)("inlineCode",{parentName:"p"},"repeat"),", the same action is performed ten times, and if we call ",(0,a.kt)("inlineCode",{parentName:"p"},"retry"),",\nthe action is attempted until successful for a maximum of ten times."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-kotlin"},"fun <A> recurTenTimes() = Schedule.recurs<A>(10)\n")),(0,a.kt)("p",null,"The exponential backoff algorithm is a standard algorithm to retry operations communicating with external services,\nsuch as network requests. Roughly, this\nmeans that the delay between attempts increases by the given factor."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-kotlin"},"@ExperimentalTime\nval exponential = Schedule.exponential<Unit>(250.milliseconds)\n")),(0,a.kt)("p",null,"Here's a much more complex schedule. Let's walk through it step by step:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"It recurs with exponential backoff as long as the delay is less than 60 seconds."),(0,a.kt)("li",{parentName:"ul"},"Afterwards, we have a spaced (constant) delay of 60 seconds for up to 100 attempts."),(0,a.kt)("li",{parentName:"ul"},"Some random noise is added by calling ",(0,a.kt)("inlineCode",{parentName:"li"},"jittered"),"."),(0,a.kt)("li",{parentName:"ul"},"We also collect every input to the schedule and return it.")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-kotlin"},"@ExperimentalTime\nfun <A> complexPolicy(): Schedule<A, List<A>> =\n  Schedule.exponential<A>(10.milliseconds).doWhile { _, duration -> duration < 60.seconds }\n    .andThen(Schedule.spaced<A>(60.seconds) and Schedule.recurs(100)).jittered()\n    .zipRight(Schedule.identity<A>().collect())\n")),(0,a.kt)("h2",{id:"repeating-an-action"},"Repeating an action"),(0,a.kt)("p",null,"When we repeat an action, we do it as long as it is successful and the\nscheduling policy tells us to keep recursing.\nFor example, this block repeats an action three times after its first successful\nexecution (so four times in total)."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-kotlin"},"suspend fun example(): Unit {\n  var counter = 0\n  val res = Schedule.recurs<Unit>(3).repeat {\n    counter++\n  }\n  counter shouldBe 4\n}\n")),(0,a.kt)("p",null,"Notice that we did not handle the error case. There are overloads\n",(0,a.kt)("a",{parentName:"p",href:"https://apidocs.arrow-kt.io/arrow-resilience/arrow.resilience/-schedule/repeat-or-else.html"},(0,a.kt)("inlineCode",{parentName:"a"},"repeatOrElse")),"\nand ",(0,a.kt)("a",{parentName:"p",href:"https://apidocs.arrow-kt.io/arrow-resilience/arrow.resilience/-schedule/repeat-or-else-either.html"},(0,a.kt)("inlineCode",{parentName:"a"},"repeatOrElseEither")),"\noffering that capability. Repeat will just rethrow any error encountered."),(0,a.kt)("h3",{id:"collecting-values"},"Collecting values"),(0,a.kt)("p",null,"Using ",(0,a.kt)("inlineCode",{parentName:"p"},"repeat"),", the resulting value is the number of iterations it has performed.\nWe're throwing away any value produced by each iteration of the repetition.\nBut we have three other possibilities:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Discard all results; that is, return ",(0,a.kt)("inlineCode",{parentName:"li"},"Unit"),"."),(0,a.kt)("li",{parentName:"ul"},"Discard all intermediate results and just keep the last produced result."),(0,a.kt)("li",{parentName:"ul"},"Keep all intermediate results.")),(0,a.kt)("p",null,"To discard the values provided by the repetition of the action, we combine our\npolicy with ",(0,a.kt)("a",{parentName:"p",href:"https://apidocs.arrow-kt.io/arrow-resilience/arrow.resilience/-schedule/-companion/unit.html"},(0,a.kt)("inlineCode",{parentName:"a"},"Schedule.unit")),",\nusing the ",(0,a.kt)("a",{parentName:"p",href:"https://apidocs.arrow-kt.io/arrow-resilience/arrow.resilience/-schedule/zip-left.html"},(0,a.kt)("inlineCode",{parentName:"a"},"zipLeft")),"\nor ",(0,a.kt)("a",{parentName:"p",href:"https://apidocs.arrow-kt.io/arrow-resilience/arrow.resilience/-schedule/zip-right.html"},(0,a.kt)("inlineCode",{parentName:"a"},"zipRight")),"\ncombinators, which keep just the output of one of the policies:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-kotlin"},"suspend fun example(): Unit {\n  var counter = 0\n\n  val keepLeft = (Schedule.identity<Unit>() zipLeft Schedule.recurs(3)).repeat {\n    counter++\n  }\n  val keepRight = (Schedule.recurs<Unit>(3) zipRight Schedule.identity<Unit>()).repeat {\n    counter++\n  }\n\n  counter shouldBe 8\n  keepLeft shouldBe Unit\n  keepRight shouldBe Unit\n}\n")),(0,a.kt)("p",null,"Following the same strategy, we can zip it with the ",(0,a.kt)("a",{parentName:"p",href:"https://apidocs.arrow-kt.io/arrow-resilience/arrow.resilience/-schedule/-companion/identity.html"},(0,a.kt)("inlineCode",{parentName:"a"},"Schedule.identity")),"\npolicy to keep only the last result of the action."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-kotlin"},'suspend fun example(): Unit {\n  var counter = 0\n\n  val keepLast = (Schedule.identity<String>() zipLeft Schedule.recurs(3)).repeat {\n    counter++; "$counter"\n  }\n  \n  keepLast shouldBe "4"\n}\n')),(0,a.kt)("p",null,"Finally, if we want to keep all intermediate results, we can zip the policy with\n",(0,a.kt)("a",{parentName:"p",href:"https://apidocs.arrow-kt.io/arrow-resilience/arrow.resilience/-schedule/-companion/collect.html"},(0,a.kt)("inlineCode",{parentName:"a"},"Schedule.collect")),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-kotlin"},"suspend fun example(): Unit {\n  var counter = 0\n\n  val keepAll = (Schedule.collect<Int>() zipLeft Schedule.recurs(3)).repeat {\n    counter++\n    counter\n  }\n\n  keepAll shouldBe listOf(1, 2, 3, 4)\n}\n")),(0,a.kt)("h3",{id:"untilwhile-it-produces-a-certain-value"},"Until/while it produces a certain value"),(0,a.kt)("p",null,"We can make use of the policies ",(0,a.kt)("a",{parentName:"p",href:"https://apidocs.arrow-kt.io/arrow-resilience/arrow.resilience/-schedule/-companion/do-while.html"},(0,a.kt)("inlineCode",{parentName:"a"},"doWhile")),"\nand ",(0,a.kt)("a",{parentName:"p",href:"https://apidocs.arrow-kt.io/arrow-resilience/arrow.resilience/-schedule/-companion/do-until.html"},(0,a.kt)("inlineCode",{parentName:"a"},"doUntil")),"\nto repeat an action while or until its produced result matches a given predicate."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-kotlin"},'suspend fun example(): Unit {\n  var result = ""\n\n  Schedule.doWhile<String>  { input, _ -> input.length <= 5 }.repeat {\n    result += "a"\n    result\n  }\n  \n  result shouldBe "aaaaaa"\n}\n')))}d.isMDXComponent=!0}}]);