"use strict";(self.webpackChunkarrow_website=self.webpackChunkarrow_website||[]).push([[6028],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>h});var a=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),u=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=u(e.components);return a.createElement(l.Provider,{value:t},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),p=u(n),m=i,h=p["".concat(l,".").concat(m)]||p[m]||d[m]||r;return n?a.createElement(h,o(o({ref:t},c),{},{components:n})):a.createElement(h,o({ref:t},c))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[p]="string"==typeof e?e:i,o[1]=s;for(var u=2;u<r;u++)o[u]=n[u];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},85162:(e,t,n)=>{n.d(t,{Z:()=>o});var a=n(67294),i=n(86010);const r={tabItem:"tabItem_Ymn6"};function o(e){let{children:t,hidden:n,className:o}=e;return a.createElement("div",{role:"tabpanel",className:(0,i.Z)(r.tabItem,o),hidden:n},t)}},74866:(e,t,n)=>{n.d(t,{Z:()=>w});var a=n(87462),i=n(67294),r=n(86010),o=n(12466),s=n(16550),l=n(91980),u=n(67392),c=n(50012);function p(e){return function(e){return i.Children.map(e,(e=>{if((0,i.isValidElement)(e)&&"value"in e.props)return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))}(e).map((e=>{let{props:{value:t,label:n,attributes:a,default:i}}=e;return{value:t,label:n,attributes:a,default:i}}))}function d(e){const{values:t,children:n}=e;return(0,i.useMemo)((()=>{const e=t??p(n);return function(e){const t=(0,u.l)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,n])}function m(e){let{value:t,tabValues:n}=e;return n.some((e=>e.value===t))}function h(e){let{queryString:t=!1,groupId:n}=e;const a=(0,s.k6)(),r=function(e){let{queryString:t=!1,groupId:n}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:t,groupId:n});return[(0,l._X)(r),(0,i.useCallback)((e=>{if(!r)return;const t=new URLSearchParams(a.location.search);t.set(r,e),a.replace({...a.location,search:t.toString()})}),[r,a])]}function f(e){const{defaultValue:t,queryString:n=!1,groupId:a}=e,r=d(e),[o,s]=(0,i.useState)((()=>function(e){let{defaultValue:t,tabValues:n}=e;if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!m({value:t,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${n.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const a=n.find((e=>e.default))??n[0];if(!a)throw new Error("Unexpected error: 0 tabValues");return a.value}({defaultValue:t,tabValues:r}))),[l,u]=h({queryString:n,groupId:a}),[p,f]=function(e){let{groupId:t}=e;const n=function(e){return e?`docusaurus.tab.${e}`:null}(t),[a,r]=(0,c.Nk)(n);return[a,(0,i.useCallback)((e=>{n&&r.set(e)}),[n,r])]}({groupId:a}),k=(()=>{const e=l??p;return m({value:e,tabValues:r})?e:null})();(0,i.useLayoutEffect)((()=>{k&&s(k)}),[k]);return{selectedValue:o,selectValue:(0,i.useCallback)((e=>{if(!m({value:e,tabValues:r}))throw new Error(`Can't select invalid tab value=${e}`);s(e),u(e),f(e)}),[u,f,r]),tabValues:r}}var k=n(72389);const b={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};function y(e){let{className:t,block:n,selectedValue:s,selectValue:l,tabValues:u}=e;const c=[],{blockElementScrollPositionUntilNextRender:p}=(0,o.o5)(),d=e=>{const t=e.currentTarget,n=c.indexOf(t),a=u[n].value;a!==s&&(p(t),l(a))},m=e=>{let t=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":{const n=c.indexOf(e.currentTarget)+1;t=c[n]??c[0];break}case"ArrowLeft":{const n=c.indexOf(e.currentTarget)-1;t=c[n]??c[c.length-1];break}}t?.focus()};return i.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.Z)("tabs",{"tabs--block":n},t)},u.map((e=>{let{value:t,label:n,attributes:o}=e;return i.createElement("li",(0,a.Z)({role:"tab",tabIndex:s===t?0:-1,"aria-selected":s===t,key:t,ref:e=>c.push(e),onKeyDown:m,onClick:d},o,{className:(0,r.Z)("tabs__item",b.tabItem,o?.className,{"tabs__item--active":s===t})}),n??t)})))}function g(e){let{lazy:t,children:n,selectedValue:a}=e;if(n=Array.isArray(n)?n:[n],t){const e=n.find((e=>e.props.value===a));return e?(0,i.cloneElement)(e,{className:"margin-top--md"}):null}return i.createElement("div",{className:"margin-top--md"},n.map(((e,t)=>(0,i.cloneElement)(e,{key:t,hidden:e.props.value!==a}))))}function v(e){const t=f(e);return i.createElement("div",{className:(0,r.Z)("tabs-container",b.tabList)},i.createElement(y,(0,a.Z)({},e,t)),i.createElement(g,(0,a.Z)({},e,t)))}function w(e){const t=(0,k.Z)();return i.createElement(v,(0,a.Z)({key:String(t)},e))}},67413:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>s,metadata:()=>u,toc:()=>p});var a=n(87462),i=(n(67294),n(3905)),r=n(74866),o=n(85162);const s={title:"Quickstart",sidebar_position:1,sidebar_custom_props:{icon:"icon-quickstart.svg"}},l="<decorated-text icon={frontMatter.sidebar_custom_props.icon}>Quickstart</decorated-text>",u={unversionedId:"ecosystem/analysis/quickstart",id:"ecosystem/analysis/quickstart",title:"Quickstart",description:"This Quickstart explains how to set up Arrow Analysis in your Gradle project, and how to use it to get further insight in your code, and to introduce additional checks in your own functions and classes.",source:"@site/content/docs/ecosystem/analysis/quickstart.md",sourceDirName:"ecosystem/analysis",slug:"/ecosystem/analysis/quickstart",permalink:"/ecosystem/analysis/quickstart",draft:!1,editUrl:"https://github.com/arrow-kt/arrow-website/edit/main/content/docs/ecosystem/analysis/quickstart.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{title:"Quickstart",sidebar_position:1,sidebar_custom_props:{icon:"icon-quickstart.svg"}},sidebar:"ecosystemSidebar",previous:{title:"Analysis",permalink:"/ecosystem/analysis/"},next:{title:"Pre and post-conditions",permalink:"/ecosystem/analysis/conditions"}},c={},p=[{value:"Adding the plug-in",id:"adding-the-plug-in",level:2},{value:"Arrow Analysis + Android",id:"arrow-analysis--android",level:3},{value:"Running the analysis",id:"running-the-analysis",level:2},{value:"Checks in functions",id:"checks-in-functions",level:2},{value:"Post-conditions",id:"post-conditions",level:3},{value:"Invariants in classes",id:"invariants-in-classes",level:2},{value:"Going further",id:"going-further",level:2}],d={toc:p},m="wrapper";function h(e){let{components:t,...n}=e;return(0,i.kt)(m,(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"quickstart"},(0,i.kt)("decorated-text",{icon:s.sidebar_custom_props.icon},"Quickstart")),(0,i.kt)("p",null,"This Quickstart explains how to set up Arrow Analysis in your Gradle project, and how to use it to get further insight in your code, and to introduce additional checks in your own functions and classes."),(0,i.kt)("admonition",{title:"Media resources",type:"info"},(0,i.kt)("ul",{parentName:"admonition"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://www.youtube.com/watch?v=yCZtnzTnpRA"},(0,i.kt)("em",{parentName:"a"},"Super-charge your build with Arrow Analysis"))," by Alejandro Serrano"))),(0,i.kt)("h2",{id:"adding-the-plug-in"},"Adding the plug-in"),(0,i.kt)(r.Z,{groupId:"build",mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"gradleKotlin",label:"Gradle (Kotlin)",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},'plugins {\n  kotlin("multiplatform") version "1.8.10"\n  // other plugins\n  id("io.arrow-kt.analysis.kotlin") version "2.0.2"\n}\n\nbuildscript {\n  repositories {\n    mavenCentral()\n  }\n}\n'))),(0,i.kt)(o.Z,{value:"gradleGroovy",label:"Gradle (Groovy)",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-groovy"},"plugins {\n  id 'org.jetbrains.kotlin.multiplatform' version '1.8.10'\n  // other plugins\n  id 'io.arrow-kt.analysis.kotlin' version '2.0.2'\n}\n\nbuildscript {\n  repositories {\n    mavenCentral()\n  }\n}\n")))),(0,i.kt)("p",null,"This adds both the Kotlin compiler plug-in, which performs the checks, and the pre and post-conditions for the Kotlin standard library. You are ready to get your first analysis results."),(0,i.kt)("h3",{id:"arrow-analysis--android"},"Arrow Analysis + Android"),(0,i.kt)("p",null,"If you want to use the plug-in in an Android project, you may run into ",(0,i.kt)("a",{parentName:"p",href:"https://youtrack.jetbrains.com/issue/KT-38576"},"this Kotlin compiler issue"),", characterized by the following error message:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-plain"},"java.lang.AssertionError: Duplicated JavaClassDescriptor ... reported to IC\n")),(0,i.kt)("p",null,"To solve this problem you have to disable precise Java tracking, by adding the following line in your ",(0,i.kt)("inlineCode",{parentName:"p"},"gradle.properties")," file:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"kotlin.incremental.usePreciseJavaTracking=false\n")),(0,i.kt)("h2",{id:"running-the-analysis"},"Running the analysis"),(0,i.kt)("p",null,"Open a new file and write the following line. This code is incorrect because you want to obtain the third element of an empty list."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"val wrong = emptyList<Int>().get(2)\n")),(0,i.kt)("p",null,"Run the analysis by executing the corresponding Gradle task (usually ",(0,i.kt)("inlineCode",{parentName:"p"},"build")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"compileKotlin"),"), and (if everything is correctly configured) you should get the following message:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-plain"},"e: Example.kt: (1, 18): pre-condition `index within bounds` is not satisfied in `get(2)`\n  -> unsatisfiable constraint: `((2 >= 0) && (2 < emptyList<Int>().size))`\n  -> `2` bound to param `index` in `kotlin.collections.List.get` \n  -> main function body\n")),(0,i.kt)("p",null,"There's a lot of information there, so let's break it into pieces:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"Example.kt: (1, 18)"),": the place where the problem lies (but you already knew that \ud83d\ude1c);"),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"pre-condition 'index within bounds' is not satisfied"),': this is the description of the problem. Something which should be true ("index within bounds") for the arguments of a function (',(0,i.kt)("em",{parentName:"li"},"pre-condition"),") is not true (not ",(0,i.kt)("em",{parentName:"li"},"satisfied"),");"),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"((2 >= 0) && (2 < emptyList<Int>().size))"),': this is the formula which expresses the "index within bounds" pre-condition more formally. By inspecting this formula, you can see that the first half (',(0,i.kt)("inlineCode",{parentName:"li"},"2 >= 0"),") is OK, but there are problems with the second half (",(0,i.kt)("inlineCode",{parentName:"li"},"2 < emptyList<Int>().size"),"), since that size is 0;"),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"'2' bound to param 'index'"),": this is additional information about the function call;"),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"main function body"),": the last part of the message describes branching information. For example, if we had an ",(0,i.kt)("inlineCode",{parentName:"li"},"if"),' expression, it would tell us whether we are in the "condition true" branch of the "condition false" branch. When there are no conditions, we just speak of ',(0,i.kt)("em",{parentName:"li"},"main function body"),".")),(0,i.kt)("p",null,"Errors arising from function calls whose pre-conditions are not safisfied are the ",(0,i.kt)("strong",{parentName:"p"},"main")," type of problems you'll encounter in the usage of Arrow Analysis."),(0,i.kt)("h2",{id:"checks-in-functions"},"Checks in functions"),(0,i.kt)("p",null,"Arrow Analysis extends the contract mechanism provided by Kotlin, and attaches two pieces of information to each function:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"its ",(0,i.kt)("em",{parentName:"li"},"pre-conditions")," describe what should be true about the arguments given to a function call,"),(0,i.kt)("li",{parentName:"ul"},"its ",(0,i.kt)("em",{parentName:"li"},"post-conditions")," describe what is true about the returned value of the function. Note that it only makes sense to talk about post-conditions once we know the pre-conditions hold.")),(0,i.kt)("p",null,"Let's write a small function which increments an integral value:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"fun increment(x: Int): Int = x + 1\n")),(0,i.kt)("p",null,"However, in our domain it only makes sense to call this function with positive numbers: the perfect job for a pre-condition. Alas, adding this pre-condition forces us to turn the simple function into a block and use ",(0,i.kt)("inlineCode",{parentName:"p"},"return"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},'import arrow.analysis.pre\n\nfun increment(x: Int): Int {\n  pre(x > 0) { "value must be positive" }\n  return x + 1\n}\n')),(0,i.kt)("p",null,"You can check that the pre-condition works by calling the function with a negative number."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"val example = increment(-1)\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-plain"},"e: pre-condition `value must be positive` is not satisfied in `increment(-1)`\n  -> unsatisfiable constraint: `(-1 > 0)`\n")),(0,i.kt)("h3",{id:"post-conditions"},"Post-conditions"),(0,i.kt)("p",null,"But what about if we change the code to the following?"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"val example = increment(increment(1))\n")),(0,i.kt)("p",null,"A very similar error arises:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-plain"},"e: pre-condition `value must be positive` is not satisfied in `increment(increment(1))`\n-> unsatisfiable constraint: `(increment(1) > 0)`\n")),(0,i.kt)("p",null,"This error tells us that Arrow Analysis was not able to deduce whether ",(0,i.kt)("inlineCode",{parentName:"p"},"increment(1)")," is positive or not. To fix the problem, we need to introduce a ",(0,i.kt)("em",{parentName:"p"},"post-condition"),", a ",(0,i.kt)("strong",{parentName:"p"},"promise")," about the result of the function. In this case, we know that given a positive number, the result of incrementing it is also positive."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},'import arrow.analysis.pre\nimport arrow.analysis.post\n\nfun increment(x: Int): Int {\n  pre(x > 0) { "value must be positive" }\n  return (x + 1).post({ it > 0 }) { "result is positive" }\n}\n')),(0,i.kt)("p",null,"The post-condition is attached to the result value of the function. The first argument works in a special way: it should be a lambda whose argument represents the return value. You'll often see ",(0,i.kt)("inlineCode",{parentName:"p"},"{ it > 0 }")," in this docs, but feel free to write it as ",(0,i.kt)("inlineCode",{parentName:"p"},"{ result -> result > 0 }")," if that looks better for you."),(0,i.kt)("p",null,"Most importantly, the error in the double call of ",(0,i.kt)("inlineCode",{parentName:"p"},"increment")," is now gone! \ud83d\ude0c"),(0,i.kt)("p",null,"Arrow Analysis does not blindly accept any post-condition you write, the tool ensure it's actually true. If you change it to ",(0,i.kt)("inlineCode",{parentName:"p"},"{ it < 0 }"),", you get an error:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"e: declaration `increment` fails to satisfy the post-condition: ($result < 0)\n")),(0,i.kt)("h2",{id:"invariants-in-classes"},"Invariants in classes"),(0,i.kt)("p",null,"Imagine now that this notion of being positive occurs very often in your domain. It makes sense then to introduce a new ",(0,i.kt)("em",{parentName:"p"},"type")," for this concept, and to ensure that any usage obbeys the positiveness condition. In this case we talk about an ",(0,i.kt)("em",{parentName:"p"},"invariant"),", something which is always true when using that particular type."),(0,i.kt)("p",null,"Arrow Analysis turns your ",(0,i.kt)("inlineCode",{parentName:"p"},"require"),"s in classes into checks at compile time."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"class Positive(val value: Int) {\n  init { require(value > 0) }\n}\n")),(0,i.kt)("p",null,"The following code is rejected with a very similar error to the ones above:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"val positiveExample = Positive(-1)\n")),(0,i.kt)("p",null,"The tool is powerful enough to track the invariants of every value involved in a computation. For example, we can introduce an addition operation with two ",(0,i.kt)("inlineCode",{parentName:"p"},"Positive")," numbers, and we can check statically that the result is again a positive number (otherwise we would not be allowed to construct an instance of ",(0,i.kt)("inlineCode",{parentName:"p"},"Positive"),")."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"fun Positive.add(other: Positive) =\n  Positive(this.value + other.value)\n")),(0,i.kt)("h2",{id:"going-further"},"Going further"),(0,i.kt)("p",null,"This Quickstart shows the basic features of Arrow Analysis. The rest of the documentation describes all its features in depth, including thorough explanations about how to track information about properties of an object, and how to deal with mutability."))}h.isMDXComponent=!0}}]);