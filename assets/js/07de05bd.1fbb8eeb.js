"use strict";(self.webpackChunkarrow_website=self.webpackChunkarrow_website||[]).push([[4690],{3905:(e,t,n)=>{n.d(t,{Zo:()=>s,kt:()=>h});var a=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var p=a.createContext({}),d=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},s=function(e){var t=d(e.components);return a.createElement(p.Provider,{value:t},e.children)},m="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,p=e.parentName,s=l(e,["components","mdxType","originalType","parentName"]),m=d(n),c=i,h=m["".concat(p,".").concat(c)]||m[c]||u[c]||r;return n?a.createElement(h,o(o({ref:t},s),{},{components:n})):a.createElement(h,o({ref:t},s))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=c;var l={};for(var p in t)hasOwnProperty.call(t,p)&&(l[p]=t[p]);l.originalType=e,l[m]="string"==typeof e?e:i,o[1]=l;for(var d=2;d<r;d++)o[d]=n[d];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},85801:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>o,default:()=>u,frontMatter:()=>r,metadata:()=>l,toc:()=>d});var a=n(87462),i=(n(67294),n(3905));const r={id:"migration",title:"Migration to Arrow 1.2.0",description:"Migration guide to upgrade to Arrow 1.2.0.",sidebar_position:2},o="Migration to Arrow 1.2.0",l={unversionedId:"learn/quickstart/migration",id:"learn/quickstart/migration",title:"Migration to Arrow 1.2.0",description:"Migration guide to upgrade to Arrow 1.2.0.",source:"@site/content/docs/learn/quickstart/migration.md",sourceDirName:"learn/quickstart",slug:"/learn/quickstart/migration",permalink:"/learn/quickstart/migration",draft:!1,editUrl:"https://github.com/arrow-kt/arrow-website/edit/main/content/docs/learn/quickstart/migration.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{id:"migration",title:"Migration to Arrow 1.2.0",description:"Migration guide to upgrade to Arrow 1.2.0.",sidebar_position:2},sidebar:"learnSidebar",previous:{title:"From other FP languages",permalink:"/learn/quickstart/from-fp"},next:{title:"Typed Errors",permalink:"/learn/typed-errors/"}},p={},d=[{value:"Either DSL, Effect &amp; EffectScope",id:"either-dsl-effect--effectscope",level:2},{value:"Using <code>Either</code>",id:"using-either",level:2},{value:"Replace <code>either { }</code>",id:"replace-either--",level:3},{value:"Replace <code>either.eager { }</code>",id:"replace-eithereager--",level:3},{value:"Replace <code>EffectScope</code>/<code>EagerEffectScope</code>",id:"replace-effectscopeeagereffectscope",level:3},{value:"Using <code>Effect</code>",id:"using-effect",level:2},{value:"Using <code>EagerEffect</code>",id:"using-eagereffect",level:2},{value:"Traverse",id:"traverse",level:3},{value:"Zip",id:"zip",level:3},{value:"Validated &amp; Either",id:"validated--either",level:2},{value:"Traverse ~&gt; mapOrAccumulate",id:"traverse--maporaccumulate",level:3},{value:"Zip",id:"zip-1",level:3},{value:"Semigroup &amp; Monoid",id:"semigroup--monoid",level:2},{value:"foldMap",id:"foldmap",level:3},{value:"combine",id:"combine",level:3},{value:"combineAll",id:"combineall",level:3},{value:"replicate",id:"replicate",level:3},{value:"Ior",id:"ior",level:2},{value:"crosswalk",id:"crosswalk",level:3},{value:"traverse",id:"traverse-1",level:3}],s={toc:d},m="wrapper";function u(e){let{components:t,...n}=e;return(0,i.kt)(m,(0,a.Z)({},s,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"migration-to-arrow-120"},"Migration to Arrow 1.2.0"),(0,i.kt)("p",null,"Arrow 1.2.0-RC is a big step in Arrow and marks the last minor version in the 1.x series, and serves as a long term version to over a graceful transition to Arrow 2.0.\nAll non-deprecated code in 1.2.0-RC is source compatible with 2.0.0, so you can slowly and gracefully migrate your codebase to Arrow 2.0.0 as soon as you want."),(0,i.kt)("p",null,"Arrow includes a lot of improvements and changes in Arrow 1.2.0-RC, all based on the feedback we've received from the community, and experience from teaching Functional Programming, building applications and knowledge from the other languages and communities.\nAny criticism is welcome, and we'll try to improve the migration guide and the library to make it as easy as possible to migrate to Arrow 2.0.0."),(0,i.kt)("p",null,"In case a deprecated method is crucial for you, please file an issue in the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/arrow-kt/arrow/issues"},"Arrow repository"),", and so Arrow can consider keeping it in the library or finding an alternative solution.\nIf you have any issues or questions, feel free to contact the Arrow maintainers in the ",(0,i.kt)("a",{parentName:"p",href:"https://arrow-kt.io/slack/"},"KotlinSlack Arrow Channel"),"."),(0,i.kt)("h2",{id:"either-dsl-effect--effectscope"},"Either DSL, Effect & EffectScope"),(0,i.kt)("p",null,"Arrow 1.0.0 introduced DSLs to work over functional data types such as ",(0,i.kt)("inlineCode",{parentName:"p"},"Either"),", and enabled several DSLs to work with ",(0,i.kt)("em",{parentName:"p"},"typed errors")," in convenient ways.\nThese DSLs were built on top of ",(0,i.kt)("inlineCode",{parentName:"p"},"Effect")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"EffectScope"),", from the ",(0,i.kt)("inlineCode",{parentName:"p"},"arrow.core.continuations")," package and had several issues, and were deprecated in Arrow 1.2.0-RC.\nThe biggest issue was that they were not compatible with Kotlin's ",(0,i.kt)("inlineCode",{parentName:"p"},"suspend")," functions, and you needed to explicitly differentiate between ",(0,i.kt)("inlineCode",{parentName:"p"},"suspend")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"non-suspend")," functions."),(0,i.kt)("p",null,"Arrow 1.2.0-RC introduces a new ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/arrow-kt/arrow/pull/2912"},(0,i.kt)("inlineCode",{parentName:"a"},"Raise")," DSL"),", which resolves this problem and allows Arrow to provide uniform APIs for typed errors across the board.\nThis heavily reduces the API surface, and makes it easier to learn and use Arrow, and additionally it allows us to build more powerful and flexible APIs.\nIf you want to learn more about the new ",(0,i.kt)("inlineCode",{parentName:"p"},"Raise")," DSL, check out the ",(0,i.kt)("a",{parentName:"p",href:"../../typed-errors"},"Typed Errors")," guide."),(0,i.kt)("p",null,"There are two ways of migrating from the old ",(0,i.kt)("inlineCode",{parentName:"p"},"Either")," DSL to the new ",(0,i.kt)("inlineCode",{parentName:"p"},"Raise")," based DSL.\nA third way using ",(0,i.kt)("a",{parentName:"p",href:"https://docs.openrewrite.org"},"OpenRewrite")," is in the works, and will be added to this guide once it's ready.\nYou can track the progress in ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/arrow-kt/rewrite-arrow"},"rewrite-arrow"),", and will provide fully automated large-scale migrations."),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Manual migration using Find + Replace"),(0,i.kt)("h2",{id:"using-either"},"Using ",(0,i.kt)("inlineCode",{parentName:"h2"},"Either")),(0,i.kt)("h3",{id:"replace-either--"},"Replace ",(0,i.kt)("inlineCode",{parentName:"h3"},"either { }")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Find + Replace ",(0,i.kt)("inlineCode",{parentName:"li"},"arrow.core.continuations.either")," -> ",(0,i.kt)("inlineCode",{parentName:"li"},"arrow.core.raise.either")),(0,i.kt)("li",{parentName:"ul"},"Find + Replace ",(0,i.kt)("inlineCode",{parentName:"li"},"arrow.core.continuations.ensureNotNull")," -> ",(0,i.kt)("inlineCode",{parentName:"li"},"arrow.core.raise.ensureNotNull")),(0,i.kt)("li",{parentName:"ul"},"Find + Replace ",(0,i.kt)("inlineCode",{parentName:"li"},"arrow.core.computations.either")," -> ",(0,i.kt)("inlineCode",{parentName:"li"},"arrow.core.raise.either")),(0,i.kt)("li",{parentName:"ul"},"Find + Replace ",(0,i.kt)("inlineCode",{parentName:"li"},"arrow.core.computations.ensureNotNull")," -> ",(0,i.kt)("inlineCode",{parentName:"li"},"arrow.core.raise.ensureNotNull"))),(0,i.kt)("h3",{id:"replace-eithereager--"},"Replace ",(0,i.kt)("inlineCode",{parentName:"h3"},"either.eager { }")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Find + Replace ",(0,i.kt)("inlineCode",{parentName:"li"},"arrow.core.continuations.either.eager")," -> ",(0,i.kt)("inlineCode",{parentName:"li"},"arrow.core.raise.either"),"\n=> Might introduce duplicate import for ",(0,i.kt)("inlineCode",{parentName:"li"},"arrow.core.raise.either")),(0,i.kt)("li",{parentName:"ul"},"Find + Replace ",(0,i.kt)("inlineCode",{parentName:"li"},"either.eager {")," -> ",(0,i.kt)("inlineCode",{parentName:"li"},"either {"))),(0,i.kt)("h3",{id:"replace-effectscopeeagereffectscope"},"Replace ",(0,i.kt)("inlineCode",{parentName:"h3"},"EffectScope"),"/",(0,i.kt)("inlineCode",{parentName:"h3"},"EagerEffectScope")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Find + Replace ",(0,i.kt)("inlineCode",{parentName:"li"},"arrow.core.continuations.EffectScope")," -> ",(0,i.kt)("inlineCode",{parentName:"li"},"arrow.core.raise.Raise")),(0,i.kt)("li",{parentName:"ul"},"Find + Replace ",(0,i.kt)("inlineCode",{parentName:"li"},"arrow.core.continuations.EagerEffectScope")," -> ",(0,i.kt)("inlineCode",{parentName:"li"},"arrow.core.raise.Raise")),(0,i.kt)("li",{parentName:"ul"},"Find + Replace ",(0,i.kt)("inlineCode",{parentName:"li"},"arrow.core.continuations.ensureNotNull")," -> ",(0,i.kt)("inlineCode",{parentName:"li"},"arrow.core.raise.ensureNotNull"))),(0,i.kt)("h2",{id:"using-effect"},"Using ",(0,i.kt)("inlineCode",{parentName:"h2"},"Effect")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Find + Replace ",(0,i.kt)("inlineCode",{parentName:"li"},"arrow.core.continuations.Effect")," -> ",(0,i.kt)("inlineCode",{parentName:"li"},"arrow.core.raise.Effect")),(0,i.kt)("li",{parentName:"ul"},"Find + Replace ",(0,i.kt)("inlineCode",{parentName:"li"},"arrow.core.continuations.ensureNotNull")," -> ",(0,i.kt)("inlineCode",{parentName:"li"},"arrow.core.raise.ensureNotNull"))),(0,i.kt)("p",null,"=> Requires manually adding missing imports for ",(0,i.kt)("inlineCode",{parentName:"p"},"fold"),", error handlers, and all ",(0,i.kt)("inlineCode",{parentName:"p"},"Effect")," methods since they're replaced by extension functions."),(0,i.kt)("h2",{id:"using-eagereffect"},"Using ",(0,i.kt)("inlineCode",{parentName:"h2"},"EagerEffect")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Find + Replace ",(0,i.kt)("inlineCode",{parentName:"li"},"arrow.core.continuations.EagerEffect")," -> ",(0,i.kt)("inlineCode",{parentName:"li"},"arrow.core.raise.EagerEffect")),(0,i.kt)("li",{parentName:"ul"},"Find + Replace ",(0,i.kt)("inlineCode",{parentName:"li"},"arrow.core.continuations.ensureNotNull")," -> ",(0,i.kt)("inlineCode",{parentName:"li"},"arrow.core.raise.ensureNotNull"))),(0,i.kt)("p",null,"=> Requires manually adding missing imports for ",(0,i.kt)("inlineCode",{parentName:"p"},"fold"),", error handlers, and all ",(0,i.kt)("inlineCode",{parentName:"p"},"EagerEffect")," methods since they're replaced by extension functions.")),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Semi-automated using KScript and IntelliJ"),(0,i.kt)("p",null,"This migration script attempts to automatically migrate ",(0,i.kt)("inlineCode",{parentName:"p"},"arrow.core.computations.*")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"arrow.core.continuations.*")," on a best effort to ",(0,i.kt)("inlineCode",{parentName:"p"},"arrow.core.raise.*"),".\nIt has been tested on several real-life projects with 100% success, being able to automatically migrate the entire codebase."),(0,i.kt)("p",null,"The run this ",(0,i.kt)("inlineCode",{parentName:"p"},"kts")," script you need ",(0,i.kt)("inlineCode",{parentName:"p"},"kotlinc")," install on your machine.\nThe official documentation on how to install ",(0,i.kt)("a",{parentName:"p",href:"https://kotlinlang.org/docs/command-line.html"},(0,i.kt)("inlineCode",{parentName:"a"},"kotlinc")),"."),(0,i.kt)("p",null,"Some methods like ",(0,i.kt)("inlineCode",{parentName:"p"},"ensure")," in the DSL became top-level, and ",(0,i.kt)("inlineCode",{parentName:"p"},"fold")," if you're using ",(0,i.kt)("inlineCode",{parentName:"p"},"Effect")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"EagerEffect"),".\nThese new ",(0,i.kt)("em",{parentName:"p"},"top-level imports")," cannot be automatically migrated, and there are two ways of dealing with the necessary imports."),(0,i.kt)("p",null,"There is two ways to use this script for migration:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Recommended: automatic ",(0,i.kt)("em",{parentName:"li"},"imports")," handling, adds too many imports and uses IntelliJ's ",(0,i.kt)("em",{parentName:"li"},"optimise imports")),(0,i.kt)("li",{parentName:"ul"},"Manual imports, doesn't add import for ",(0,i.kt)("inlineCode",{parentName:"li"},"fold"),", and ",(0,i.kt)("inlineCode",{parentName:"li"},"ensure")," and requires manually importing them on a usage basis.")),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Recommended usage"),(0,i.kt)("p",null,"Once installed you can run the script with default params: ",(0,i.kt)("inlineCode",{parentName:"p"},"kotlinc -script migrate.main.kts ."),"."),(0,i.kt)("p",null,"You need to have Arrow version ",(0,i.kt)("inlineCode",{parentName:"p"},"1.2.0-RC")," (or newer) in order to compile your project after the script finishes running."),(0,i.kt)("p",null,"The script ",(0,i.kt)("em",{parentName:"p"},"might")," leave you with some unused imports, to fix this you can run ",(0,i.kt)("em",{parentName:"p"},"optimise imports")," on your ",(0,i.kt)("em",{parentName:"p"},"project root")," or ",(0,i.kt)("em",{parentName:"p"},"src")," folder."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Select ",(0,i.kt)("em",{parentName:"li"},"src")," or _project root",(0,i.kt)("inlineCode",{parentName:"li"},"+"),"\u2303 \u2325 O",(0,i.kt)("inlineCode",{parentName:"li"},"or"),"Ctrl+Alt+O`."),(0,i.kt)("li",{parentName:"ul"},"Right-click ",(0,i.kt)("em",{parentName:"li"},"project root")," or ",(0,i.kt)("em",{parentName:"li"},"src")," in ",(0,i.kt)("em",{parentName:"li"},"project view"),", and select ",(0,i.kt)("em",{parentName:"li"},"Optimise imports"))),(0,i.kt)("p",null,"This should remove all ",(0,i.kt)("em",{parentName:"p"},"unused imports")," this might also affect other unrelated imports.")),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Alternative"),(0,i.kt)("p",null,"If you don't want to rely on IntelliJ's ",(0,i.kt)("em",{parentName:"p"},"optimise imports")," you can still use the migration script to do 99,99% of the work,\nexcept import ",(0,i.kt)("inlineCode",{parentName:"p"},"ensure")," (and ",(0,i.kt)("inlineCode",{parentName:"p"},"fold")," for ",(0,i.kt)("inlineCode",{parentName:"p"},"Effect"),"/",(0,i.kt)("inlineCode",{parentName:"p"},"EagerEffect"),")."),(0,i.kt)("p",null,"Easiest way to fix the imports is run ",(0,i.kt)("inlineCode",{parentName:"p"},"./gradlew build")," and add missing imports in files that fail to compile."),(0,i.kt)("p",null,"Thank you for using Arrow, and your support. I hope this script was able to simplify your migration process to 2.0.0"))),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"Below we discuss ",(0,i.kt)("inlineCode",{parentName:"p"},"traverse")," & ",(0,i.kt)("inlineCode",{parentName:"p"},"zip")," which will be adopted by ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/cashapp/quiver"},"Quiver")," in the future.\nSo if you like using these ",(0,i.kt)("em",{parentName:"p"},"functional combinators")," you can ignore their deprecated status, and continue using them with ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/cashapp/quiver"},"Quiver")," after 2.0.0\nWe will also provide ",(0,i.kt)("a",{parentName:"p",href:"https://docs.openrewrite.org"},"OpenRewrite")," recipes through ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/arrow-kt/rewrite-arrow"},"rewrite-arrow")," when 2.0.0 is released to automatically migrate to ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/cashapp/quiver"},"Quiver"),".")),(0,i.kt)("h3",{id:"traverse"},"Traverse"),(0,i.kt)("p",null,"All ",(0,i.kt)("inlineCode",{parentName:"p"},"traverse")," functionality has been deprecated in favor of Kotlin's ",(0,i.kt)("inlineCode",{parentName:"p"},"map")," function, and it ",(0,i.kt)("em",{parentName:"p"},"should")," be possible to migrate automatically using Kotlin & IntelliJ's ",(0,i.kt)("inlineCode",{parentName:"p"},"ReplaceWith"),".\nLet's look at a simple example to illustrate the difference between ",(0,i.kt)("inlineCode",{parentName:"p"},"traverse"),", and the ",(0,i.kt)("em",{parentName:"p"},"new")," resulting code. We'll be using ",(0,i.kt)("inlineCode",{parentName:"p"},"Either")," in this example, but it should be the same for any other collection type that has a ",(0,i.kt)("inlineCode",{parentName:"p"},"traverse")," method.\nThe rationale behind this change is while ",(0,i.kt)("inlineCode",{parentName:"p"},"traverse")," is a very well known method within the FP community, it's not as well known outside of it.\nUsing ",(0,i.kt)("inlineCode",{parentName:"p"},"map")," is more familiar to most developers, and using ",(0,i.kt)("inlineCode",{parentName:"p"},"bind")," gives a more consistent experience with the rest of the DSL. Additionally, when working over ",(0,i.kt)("inlineCode",{parentName:"p"},"Raise<E>")," the ",(0,i.kt)("inlineCode",{parentName:"p"},"bind")," method would disappear and ",(0,i.kt)("inlineCode",{parentName:"p"},"map === traverse"),"."),(0,i.kt)("admonition",{title:"accumulating errors",type:"warning"},(0,i.kt)("p",{parentName:"admonition"},"If you're refactoring code using ",(0,i.kt)("inlineCode",{parentName:"p"},"Validated")," check the ",(0,i.kt)("a",{parentName:"p",href:"#validated--either"},"Validated & Either")," section.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"fun one(): Either<String, Int> = Either.Right(1)\n\nval old: Either<String, List<Int>> = \n  listOf(1, 2, 3).traverse { one() }\n\nval new: Either<String, List<Int>> = either {\n  listOf(1, 2, 3).map { one().bind() }\n}\n")),(0,i.kt)("h3",{id:"zip"},"Zip"),(0,i.kt)("p",null,"In similar fashion to ",(0,i.kt)("inlineCode",{parentName:"p"},"traverse"),", all ",(0,i.kt)("inlineCode",{parentName:"p"},"zip")," methods have been deprecated in favor of the DSL, and it ",(0,i.kt)("em",{parentName:"p"},"should")," be possible to migrate automatically using Kotlin & IntelliJ's ",(0,i.kt)("inlineCode",{parentName:"p"},"ReplaceWith"),".\nThe rationale behind deprecating ",(0,i.kt)("inlineCode",{parentName:"p"},"zip")," was that it's behavior is now duplicated by the ",(0,i.kt)("inlineCode",{parentName:"p"},"bind")," method, and since the DSLs are now fully ",(0,i.kt)("inlineCode",{parentName:"p"},"inline")," it makes ",(0,i.kt)("inlineCode",{parentName:"p"},"zip")," redundant.\nWorking with ",(0,i.kt)("inlineCode",{parentName:"p"},"zip")," requires dealing with the ",(0,i.kt)("em",{parentName:"p"},"arity-n")," problem, which means that the ",(0,i.kt)("inlineCode",{parentName:"p"},"zip")," method is only defined for ",(0,i.kt)("inlineCode",{parentName:"p"},"9 arguments")," in Arrow but can be defined for any ",(0,i.kt)("inlineCode",{parentName:"p"},"n")," number of arguments.\nThe DSL, and ",(0,i.kt)("inlineCode",{parentName:"p"},"bind"),", don't suffer from this problem, and it's possible to use ",(0,i.kt)("inlineCode",{parentName:"p"},"bind")," with any number of arguments thus getting rid of this problem. See ",(0,i.kt)("a",{parentName:"p",href:"https://stackoverflow.com/questions/72782045/arrow-validation-more-then-10-fields/72782420#72782420"},"this question on StackOverflow"),". "),(0,i.kt)("p",null,"Let's look at a simple example to illustrate the difference between ",(0,i.kt)("inlineCode",{parentName:"p"},"zip"),", and the ",(0,i.kt)("em",{parentName:"p"},"new")," resulting code.\nWe'll be using ",(0,i.kt)("inlineCode",{parentName:"p"},"Either")," in this example, but it should be the same for any other data type that has a ",(0,i.kt)("inlineCode",{parentName:"p"},"zip")," method."),(0,i.kt)("admonition",{title:"accumulating errors",type:"warning"},(0,i.kt)("p",{parentName:"admonition"},"If you're refactoring code using ",(0,i.kt)("inlineCode",{parentName:"p"},"Validated")," check the ",(0,i.kt)("a",{parentName:"p",href:"#validated--either"},"Validated & Either")," section.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"fun one(): Either<String, Int> = Either.Right(1)\n\nval old: Either<String, Int> = one().zip(one()) { x, y -> x + y }\n\nval new: Either<String, Int> =\n  either { one().bind() + one().bind() }\n\nval new2 : Either<String, Int> = either { \n  val x = one().bind()\n  val y = one().bind()\n  x + y\n}\n")),(0,i.kt)("h2",{id:"validated--either"},"Validated & Either"),(0,i.kt)("p",null,"In Arrow 1.2.0-RC we've deprecated ",(0,i.kt)("inlineCode",{parentName:"p"},"Validated")," in favor of ",(0,i.kt)("inlineCode",{parentName:"p"},"Either"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"ValidatedNel")," in favor of ",(0,i.kt)("inlineCode",{parentName:"p"},"EitherNel"),".\nRationale was that ",(0,i.kt)("inlineCode",{parentName:"p"},"Either")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Validated")," offer the same abstraction of ",(0,i.kt)("em",{parentName:"p"},"either")," an error of type ",(0,i.kt)("inlineCode",{parentName:"p"},"E")," or a value of type ",(0,i.kt)("inlineCode",{parentName:"p"},"A"),".\nThe main reason is that ",(0,i.kt)("inlineCode",{parentName:"p"},"zip")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"traverse")," behave differently in these data types. Where ",(0,i.kt)("inlineCode",{parentName:"p"},"Validated")," allows ",(0,i.kt)("em",{parentName:"p"},"accumulating errors")," using ",(0,i.kt)("inlineCode",{parentName:"p"},"zip")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"traverse"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Either")," short-circuits on the first error."),(0,i.kt)("p",null,"This behavior can be bridged by concrete APIs in the new ",(0,i.kt)("inlineCode",{parentName:"p"},"Raise")," DSL whilst supporting ",(0,i.kt)("strong",{parentName:"p"},"both")," working over ",(0,i.kt)("inlineCode",{parentName:"p"},"E")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"NonEmptyList<E>")," in singular APIs.\nSo you don't have to redundantly lift all your return types to work over ",(0,i.kt)("inlineCode",{parentName:"p"},"NonEmptyList<E>")," when you're actually returning a single error ",(0,i.kt)("inlineCode",{parentName:"p"},"E"),". That can be transparently supported inside the new ",(0,i.kt)("inlineCode",{parentName:"p"},"Raise")," DSL APIs to ",(0,i.kt)("em",{parentName:"p"},"accumulate")," errors.\nThese new APIs still support ",(0,i.kt)("inlineCode",{parentName:"p"},"Validated")," until it's actually removed in Arrow 2.0.0, and we advise to migrate those before actually migrating ",(0,i.kt)("inlineCode",{parentName:"p"},"Validated")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"Either"),". "),(0,i.kt)("p",null,"To migrate from ",(0,i.kt)("inlineCode",{parentName:"p"},"Validated")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"Either")," you need to simply construct ",(0,i.kt)("inlineCode",{parentName:"p"},"Either")," values instead of ",(0,i.kt)("inlineCode",{parentName:"p"},"Validated"),", and leverage the new APIs clarified below."),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Semi-automatic migration using ReplaceWith"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Start leveraging the ",(0,i.kt)("inlineCode",{parentName:"p"},"Raise")," ",(0,i.kt)("em",{parentName:"p"},"accumulate error")," APIs before migrating ",(0,i.kt)("inlineCode",{parentName:"p"},"Validated")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"Either"),": ",(0,i.kt)("inlineCode",{parentName:"p"},"zip")," -> ",(0,i.kt)("inlineCode",{parentName:"p"},"zipOrAccumulate")," & ",(0,i.kt)("inlineCode",{parentName:"p"},"traverse")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"mapOrAccumulate")," using ",(0,i.kt)("em",{parentName:"p"},"Replace in entire project action")," from IntelliJ")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Migrate all remaining APIs to their ",(0,i.kt)("inlineCode",{parentName:"p"},"Either")," equivalent ",(0,i.kt)("inlineCode",{parentName:"p"},"tapInvalid"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"withEither"),", etc. All overlapping APIs such as ",(0,i.kt)("inlineCode",{parentName:"p"},"map"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"fold"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"getOrElse")," can be ignored. ")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Migrate all constructors:"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Validated.Valid")," -> ",(0,i.kt)("inlineCode",{parentName:"li"},"Either.Right")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Validated.Invalid")," -> ",(0,i.kt)("inlineCode",{parentName:"li"},"Either.Left")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"A.valid()")," -> ",(0,i.kt)("inlineCode",{parentName:"li"},"A.right()")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"A.validNel()")," -> ",(0,i.kt)("inlineCode",{parentName:"li"},"A.right()")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"E.invalid()")," -> ",(0,i.kt)("inlineCode",{parentName:"li"},"E.left()")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"E.invalidNel()")," -> ",(0,i.kt)("inlineCode",{parentName:"li"},"E.leftNel()")))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Replace in entire project ",(0,i.kt)("inlineCode",{parentName:"p"},"Either#toEither()")," intermediate method"))),(0,i.kt)("video",{width:"100%",height:"100%","data-autoplay":!0,"data-loop":!0,src:"https://user-images.githubusercontent.com/12424668/220732907-27933876-3349-41d5-b0f2-a53b12f2f217.mov",type:"video/webm"})),(0,i.kt)("h3",{id:"traverse--maporaccumulate"},"Traverse ~> mapOrAccumulate"),(0,i.kt)("p",null,"The behavior of ",(0,i.kt)("inlineCode",{parentName:"p"},"traverse")," for ",(0,i.kt)("inlineCode",{parentName:"p"},"Validated")," is now supported by ",(0,i.kt)("inlineCode",{parentName:"p"},"mapOrAccumulate")," so let's take a quick look at what it looks like:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},'fun one(): Either<String, Int> = "error-1".left()\nfun two(): Either<NonEmptyList<String>, Int> = nonEmptyListOf("error-2", "error-3").left()\n\nfun example() {\n  listOf(1, 2).mapOrAccumulate {\n    one().bind()\n  } shouldBe nonEmptyListOf("error-1", "error-1").left()\n  \n  listOf(1, 2).mapOrAccumulate {\n    two().bind()\n  } shouldBe nonEmptyListOf("error-2", "error-3", "error-2", "error-3").left()\n}\n')),(0,i.kt)("h3",{id:"zip-1"},"Zip"),(0,i.kt)("p",null,"The behavior of ",(0,i.kt)("inlineCode",{parentName:"p"},"zip")," for ",(0,i.kt)("inlineCode",{parentName:"p"},"Validated")," is now supported by ",(0,i.kt)("inlineCode",{parentName:"p"},"zipOrAccumulate")," so let's take a quick look at what it looks like:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},'fun one(): Either<String, Int> = "error-1".left()\nfun two(): Either<NonEmptyList<String>, Int> = nonEmptyListOf("error-2", "error-3").left()\n\nfun example() {\n  either<NonEmptyList<String>, Int> {\n    zipOrAccumulate(\n      { one().bind() },\n      { two().bindNel() }\n    ) { x, y -> x + y }\n  } shouldBe nonEmptyListOf("error-1", "error-2", "error-3").left()\n}\n')),(0,i.kt)("h2",{id:"semigroup--monoid"},"Semigroup & Monoid"),(0,i.kt)("p",null,"Both ",(0,i.kt)("inlineCode",{parentName:"p"},"Semigroup")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Monoid")," are deprecated in Arrow ",(0,i.kt)("inlineCode",{parentName:"p"},"1.2.0")," and will be removed in ",(0,i.kt)("inlineCode",{parentName:"p"},"2.0.0"),". The migration of\nsome deprecated methods may need to add an extra manual step, besides the automatic replacement. "),(0,i.kt)("h3",{id:"foldmap"},"foldMap"),(0,i.kt)("p",null,"The replacement of deprecated ",(0,i.kt)("inlineCode",{parentName:"p"},"foldMap")," for ",(0,i.kt)("inlineCode",{parentName:"p"},"Iterable"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Option")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Either")," requires to replace the ",(0,i.kt)("inlineCode",{parentName:"p"},"Monoid")," parameter\nwith an ",(0,i.kt)("inlineCode",{parentName:"p"},"empty")," value of the type contained in the removed ",(0,i.kt)("inlineCode",{parentName:"p"},"Monoid"),".\nLet's see this in action:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},'fun booleanToString(b: Boolean): String = if (b) "IS TRUE! :)" else "IS FALSE.... :(" \n\nfun deprecatedFoldMap() {\n   val e1: Either<String, Boolean> = false.right()\n   e1.foldMap(Monoid.string(), ::booleanToString) shouldBe "IS FALSE.... :("\n}\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'// Executing automatic replacement\nfun migrateFoldMap() {\n   val e1: Either<String, Boolean> = false.right()\n   e1.fold({empty}, ::booleanToString) shouldBe "IS FALSE.... :(" // empty is not found\n}\n \n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},'// Adding the empty value to complete the replacement of the deprecated method\nfun migrateFoldMap() {\n   val e1: Either<String, Boolean> = false.right()\n   e1.fold({""}, ::booleanToString) shouldBe "IS FALSE.... :("\n}\n')),(0,i.kt)("h3",{id:"combine"},"combine"),(0,i.kt)("p",null,"All deprecated ",(0,i.kt)("inlineCode",{parentName:"p"},"combine")," methods are suggested to be replaced by the lambda ",(0,i.kt)("inlineCode",{parentName:"p"},"{a, b -> a + b}"),", which will cover almost all\npossible replacements successfully. One of the cases that will need some manual fix is the following:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"fun deprecatedZip() {\n   val nullableLongMonoid = object : Monoid<Long?> {\n      override fun empty(): Long? = 0\n      override fun Long?.combine(b: Long?): Long? =\n         nullable { this@combine.bind() + b.bind() }\n   }\n\n   val validated: Validated<Long?, Int?> = 3.valid()\n   val res = validated.zip(nullableLongMonoid, Valid(Unit)) { a, _ -> a } // zip and Monoid are deprecated\n   res shouldBe Validated.Valid(3)\n}\n")),(0,i.kt)("p",null,"When we replace the deprecated ",(0,i.kt)("inlineCode",{parentName:"p"},"zip")," method:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"// Executing automatic replacement\nfun migrateZip(){ \n   val validated: Validated<Long?, Int?> = 3.valid()\n   val res = Either.zipOrAccumulate(\n      { e1, e2 -> e1 + e2 }, // compilation error\n      validated.toEither(), \n      Valid(Unit).toEither()\n   ) { a, _ -> a }.toValidated()\n}\n")),(0,i.kt)("p",null,"In this case, we do not have the ",(0,i.kt)("inlineCode",{parentName:"p"},"+")," operation for ",(0,i.kt)("inlineCode",{parentName:"p"},"Long?"),", so we need to add it manually:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"fun migrateZip() {\n   val validated: Validated<Long?, Int?> = 3.valid()\n   val res = Either.zipOrAccumulate(\n      { e1, e2 -> nullable { e1.bind() + e2.bind() } },\n      validated.toEither(),\n      Valid(Unit).toEither()\n   ) { a, _ -> a }.toValidated()\n   res shouldBe Validated.Valid(3)\n}\n")),(0,i.kt)("h3",{id:"combineall"},"combineAll"),(0,i.kt)("p",null,"In a similar situation like ",(0,i.kt)("a",{parentName:"p",href:"#foldmap"},"foldMap"),", the replacement of deprecated ",(0,i.kt)("inlineCode",{parentName:"p"},"combineAll")," for ",(0,i.kt)("inlineCode",{parentName:"p"},"Iterable"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Option")," and\n",(0,i.kt)("inlineCode",{parentName:"p"},"Validate")," needs to add manually the ",(0,i.kt)("inlineCode",{parentName:"p"},"initial")," parameter, in the replacement with ",(0,i.kt)("inlineCode",{parentName:"p"},"fold")," method. Let's do a replacement\nto see how to achieve this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"fun deprecatedCombineAll() {\n   val l: List<Int> = listOf(1, 2, 3, 4, 5)\n   l.combineAll(Monoid.int()) shouldBe 10\n}\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"// Executing automatic replacement\nfun migrateCombineAll(){\n   val l: List<Int> = listOf(1, 2, 3, 4, 5) \n   l.fold(initial) { a1, a2 -> a1 + a2 } shouldBe 10 // initial is not found\n}\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"// Adding the initial value to complete the replacement of the deprecated method\nfun migrateCombineAll() {\n   val l: List<Int> = listOf(1, 2, 3, 4, 5)\n   l.fold(0) { a1, a2 -> a1 + a2 } shouldBe 10\n}\n")),(0,i.kt)("h3",{id:"replicate"},"replicate"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"replicate")," also needs a bit of ",(0,i.kt)("em",{parentName:"p"},"help")," when removing the deprecated ",(0,i.kt)("inlineCode",{parentName:"p"},"Monoid")," for ",(0,i.kt)("inlineCode",{parentName:"p"},"Option")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Either"),". Again,\n",(0,i.kt)("inlineCode",{parentName:"p"},"fold")," is the recommended replacement method, so we'll need to provide the ",(0,i.kt)("inlineCode",{parentName:"p"},"initial")," parameter in the ",(0,i.kt)("inlineCode",{parentName:"p"},"fold"),". Let's see this\nwith an ",(0,i.kt)("inlineCode",{parentName:"p"},"Either"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"fun deprecatedReplicate() {\n   val rEither: Either<String, Int> = 125.right()\n   val n = 3\n   rEither.replicate(n, Monoid.int()) shouldBe Either.Right(375)\n}\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"// Executing automatic replacement\nfun migrateReplicate(){\n   val rEither: Either<String, Int> = 125.right() \n   val n = 3\n   val res = if (n <= 0) Either.Right(initial) \n   else rEither.map { b -> List<Int>(n) { b }.fold(initial) { r, t -> r + t } } // initial is not found\n   res shouldBe Either.Right(375)\n}\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"// Adding the empty value to complete the replacement of the deprecated method\nfun migrateReplicate() {\n   val rEither: Either<String, Int> = 125.right()\n   val n = 3\n   val res = if (n <= 0) Either.Right(0)\n   else rEither.map { b -> List<Int>(n) { b }.fold(0) { r, t -> r + t } }\n\n   res shouldBe Either.Right(375)\n}\n")),(0,i.kt)("h2",{id:"ior"},"Ior"),(0,i.kt)("p",null,"Most of the ",(0,i.kt)("inlineCode",{parentName:"p"},"Ior")," data type deprecated method migrations related to ",(0,i.kt)("inlineCode",{parentName:"p"},"traverse")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"crosswalk"),",\nmust be replaced manually. The main reason is that ",(0,i.kt)("inlineCode",{parentName:"p"},"Intellij")," does not know how to infer some types when we're using\ngenerics. Although this situation can be a bit annoying, this is a good excuse for the user to navigate and get more expertise\non the ",(0,i.kt)("inlineCode",{parentName:"p"},"Arrow")," source code. Let's see a few examples to be more familiar with these special cases:"),(0,i.kt)("h3",{id:"crosswalk"},"crosswalk"),(0,i.kt)("p",null,"Given the ",(0,i.kt)("inlineCode",{parentName:"p"},"Ior")," implementation of ",(0,i.kt)("inlineCode",{parentName:"p"},"crosswalk"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"public inline fun <C> crosswalk(fa: (B) -> Iterable<C>): List<Ior<A, C>> =\n    fold(\n      { emptyList() },\n      { b -> fa(b).map { Right(it) } },\n      { a, b -> fa(b).map { Both(a, it) } }\n    )\n")),(0,i.kt)("p",null,"And an example that use ",(0,i.kt)("inlineCode",{parentName:"p"},"crosswalk"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"fun deprecatedCrosswalk() {\n   val rightIor: Ior<String, Int> = Ior.Right(124)\n   val result = rightIor.crosswalk { listOf(it) }\n   result shouldBe listOf(Ior.Right(124))\n}\n")),(0,i.kt)("p",null,"The result of replacing manually the ",(0,i.kt)("inlineCode",{parentName:"p"},"crosswalk")," call using the ",(0,i.kt)("inlineCode",{parentName:"p"},"fold")," implementation would be:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"fun migrateCrosswalk() {\n   val rightIor: Ior<String, Int> = Ior.Right(124)\n   val result = rightIor.fold(\n      { emptyList<Int>() },\n      { b -> listOf(b).map { Ior.Right(it) } },\n      { a, b -> listOf(b).map { Ior.Both(a, it) } }\n   )\n   result shouldBe listOf(Ior.Right(124))\n}\n")),(0,i.kt)("h3",{id:"traverse-1"},"traverse"),(0,i.kt)("p",null,"In a similar situation we have the ",(0,i.kt)("inlineCode",{parentName:"p"},"Ior")," ",(0,i.kt)("inlineCode",{parentName:"p"},"traverse")," method for a function that returns an ",(0,i.kt)("inlineCode",{parentName:"p"},"Option"),".\nGiven the implementation of ",(0,i.kt)("inlineCode",{parentName:"p"},"traverse"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"public inline fun <C> traverse(fa: (B) -> Option<C>): Option<Ior<A, C>> {\n    return fold(\n      { a -> Some(Left(a)) },\n      { b -> fa(b).map { Right(it) } },\n      { a, b -> fa(b).map { Both(a, it) } }\n    )\n  }\n")),(0,i.kt)("p",null,"And an example that use ",(0,i.kt)("inlineCode",{parentName:"p"},"traverse"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"fun evenOpt(i: Int): Option<Int> = if(i % 2 == 0) i.some() else None\n\nfun deprecatedTraverse() {\n   val rightIor: Ior<String, Int> = Ior.Right(124)\n   val result = rightIor.traverse { evenOpt(it) }\n\n   result shouldBe Some(Ior.Right(124))\n}\n")),(0,i.kt)("p",null,"The result of replacing manually the ",(0,i.kt)("inlineCode",{parentName:"p"},"traverse")," call using the ",(0,i.kt)("inlineCode",{parentName:"p"},"fold")," implementation would be:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"fun evenOpt(i: Int): Option<Int> = if(i % 2 == 0) i.some() else None\n\nfun migrateTraverse() {\n   val rightIor: Ior<String, Int> = Ior.Right(124)\n   val result = rightIor.fold(\n      { a -> Some(Ior.Left(a)) },\n      { b -> evenOpt(b).map { Ior.Right(it) } },\n      { a, b -> evenOpt(b).map { Ior.Both(a, it) } }\n   )\n\n   result shouldBe Some(Ior.Right(124))\n}\n")))}u.isMDXComponent=!0}}]);