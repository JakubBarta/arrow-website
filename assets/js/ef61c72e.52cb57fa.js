"use strict";(self.webpackChunkarrow_website=self.webpackChunkarrow_website||[]).push([[9863],{3905:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>d});var i=t(67294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,i)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function c(e,n){if(null==e)return{};var t,i,o=function(e,n){if(null==e)return{};var t,i,o={},a=Object.keys(e);for(i=0;i<a.length;i++)t=a[i],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(i=0;i<a.length;i++)t=a[i],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var l=i.createContext({}),s=function(e){var n=i.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},u=function(e){var n=s(e.components);return i.createElement(l.Provider,{value:n},e.children)},p="mdxType",m={inlineCode:"code",wrapper:function(e){var n=e.children;return i.createElement(i.Fragment,{},n)}},f=i.forwardRef((function(e,n){var t=e.components,o=e.mdxType,a=e.originalType,l=e.parentName,u=c(e,["components","mdxType","originalType","parentName"]),p=s(t),f=o,d=p["".concat(l,".").concat(f)]||p[f]||m[f]||a;return t?i.createElement(d,r(r({ref:n},u),{},{components:t})):i.createElement(d,r({ref:n},u))}));function d(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var a=t.length,r=new Array(a);r[0]=f;var c={};for(var l in n)hasOwnProperty.call(n,l)&&(c[l]=n[l]);c.originalType=e,c[p]="string"==typeof e?e:o,r[1]=c;for(var s=2;s<a;s++)r[s]=t[s];return i.createElement.apply(null,r)}return i.createElement.apply(null,t)}f.displayName="MDXCreateElement"},37904:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>m,frontMatter:()=>a,metadata:()=>c,toc:()=>s});var i=t(87462),o=(t(67294),t(3905));const a={sidebar_position:2,description:"Making functions stack-safe and efficient"},r="Recursive functions",c={unversionedId:"learn/collections-functions/recursive",id:"learn/collections-functions/recursive",title:"Recursive functions",description:"Making functions stack-safe and efficient",source:"@site/content/docs/learn/collections-functions/recursive.md",sourceDirName:"learn/collections-functions",slug:"/learn/collections-functions/recursive",permalink:"/learn/collections-functions/recursive",draft:!1,editUrl:"https://github.com/arrow-kt/arrow-website/edit/main/content/docs/learn/collections-functions/recursive.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2,description:"Making functions stack-safe and efficient"},sidebar:"learnSidebar",previous:{title:"Non-empty collections",permalink:"/learn/collections-functions/non-empty"},next:{title:"Utilities for functions",permalink:"/learn/collections-functions/utils"}},l={},s=[{value:"Stack-safe deep recursive functions",id:"stack-safe-deep-recursive-functions",level:2},{value:"Memoization",id:"memoization",level:2}],u={toc:s},p="wrapper";function m(e){let{components:n,...t}=e;return(0,o.kt)(p,(0,i.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"recursive-functions"},"Recursive functions"),(0,o.kt)("p",null,"Algorithms with a functional flavor tend to favor recursion over looping.\nThis is often hidden in higher-level functions like ",(0,o.kt)("inlineCode",{parentName:"p"},"map")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"filter"),",\nso you don't often see it on your code. However, when the time comes, some\nplatforms (including the JVM) can make your life quite difficult: deep\nrecursion means a deep stack, so you can easily get a ",(0,o.kt)("inlineCode",{parentName:"p"},"StackOverflowError"),",\neven for not-so-big values."),(0,o.kt)("h2",{id:"stack-safe-deep-recursive-functions"},"Stack-safe deep recursive functions"),(0,o.kt)("p",null,"Kotlin comes with a built-in ",(0,o.kt)("a",{parentName:"p",href:"https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-deep-recursive-function/"},(0,o.kt)("inlineCode",{parentName:"a"},"DeepRecursiveFunction")),"\nwhich solves this problem by keeping the call stack in the heap, which usually\nhas a much bigger memory space allocated to it."),(0,o.kt)("p",null,"The ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Fibonacci_sequence"},"Fibonacci sequence")," is\nan all-time favorite example of a recursive operation which requires a deep stack\neven for small values. The function is only defined for non-negative ",(0,o.kt)("inlineCode",{parentName:"p"},"n"),",\nso we split the actual worker function from the top-level one, which checks the\nconstraint over the argument."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},"fun fibonacciWorker(n: Int): Int = when (n) {\n  0 -> 0\n  1 -> 1\n  else -> fibonacciWorker(n - 1) + fibonacciWorker(n - 2)\n}\n\nfun fibonacci(n: Int): Int {\n  require(n >= 0)\n  return fibonacciWorker(n)\n}\n\nfun example() {\n  fibonacci(6) shouldBe 8\n}\n")),(0,o.kt)("p",null,"To make this function stack-safe we move the worker from being a regular\nfunction into being a ",(0,o.kt)("inlineCode",{parentName:"p"},"DeepRecursiveFunction"),". The latter takes a block which\ndefines the function, very similar to a regular one. The key change is that\ninstead of calling ",(0,o.kt)("inlineCode",{parentName:"p"},"fibonacciWorker"),", we use ",(0,o.kt)("inlineCode",{parentName:"p"},"callRecursive")," every time we\nneed recursion."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},"val fibonacciWorker = DeepRecursiveFunction<Int, Int> { n ->\n  when (n) {\n    0 -> 0\n    1 -> 1\n    else -> callRecursive(n - 1) + callRecursive(n - 2)\n  }\n}\n")),(0,o.kt)("admonition",{title:"Function in a val",type:"caution"},(0,o.kt)("p",{parentName:"admonition"},"Note that we've used ",(0,o.kt)("inlineCode",{parentName:"p"},"val")," to save the ",(0,o.kt)("inlineCode",{parentName:"p"},"DeepRecursiveFunction"),", instead of\n",(0,o.kt)("inlineCode",{parentName:"p"},"fun"),". However, since that type overloads the ",(0,o.kt)("inlineCode",{parentName:"p"},"invoke")," operator, we still\ncan call it as if it was a function, so no changes are required for ",(0,o.kt)("inlineCode",{parentName:"p"},"fibonacci"),".")),(0,o.kt)("h2",{id:"memoization"},"Memoization"),(0,o.kt)("p",null,"There's an enormous amount of duplicate work being done in a call to ",(0,o.kt)("inlineCode",{parentName:"p"},"fibonacci"),".\nHere is the call tree of ",(0,o.kt)("inlineCode",{parentName:"p"},"fibonacciWorker(4)"),", you can see that we end up in\n",(0,o.kt)("inlineCode",{parentName:"p"},"fibonacci(2)")," a couple of times. Not only that: we can see that in the recursive\ncall for ",(0,o.kt)("inlineCode",{parentName:"p"},"n - 1")," we eventually require the value for ",(0,o.kt)("inlineCode",{parentName:"p"},"n - 2")," too. Could we make\nthis function a bit less wasteful?"),(0,o.kt)("mermaid",{value:"graph TD;\n  4--\x3e3a;\n  3a[3];\n  3a--\x3e2a;\n  3a--\x3e1a;\n  2a[2];\n  1a[1];\n  2a--\x3e1b;\n  1b[1];\n  2a--\x3e0b;\n  0b[0]\n  4--\x3e2b;\n  2b[2];\n  2b--\x3e1c;\n  1c[1];\n  2b--\x3e0c;\n  0c[0];"}),(0,o.kt)("admonition",{title:"Fibonacci \ud83e\udd2f",type:"info"},(0,o.kt)("p",{parentName:"admonition"},"The number of calls required to compute Fibonacci is also given by the Fibonacci\nsequence!")),(0,o.kt)("p",null,"Fibonacci is a pure function, in other words, given the same argument we always\nobtain the same result. This means that once we've computed a value, we can just\n",(0,o.kt)("em",{parentName:"p"},"record")," in some cache, so later invocations only have to look there. This\ntechnique is known as ",(0,o.kt)("strong",{parentName:"p"},"memoization"),", and Arrow provides an implementation\nin the form of ",(0,o.kt)("a",{parentName:"p",href:"https://apidocs.arrow-kt.io/arrow-core/arrow.core/memoize.html"},(0,o.kt)("inlineCode",{parentName:"a"},"memoize")),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},"import arrow.core.memoize\n\nval fibonacciMemoized = ::fibonacciWorker.memoize()\n\nfun fibonacci(n: Int): Int {\n  require(n >= 0)\n  return fibonacciMemoized(n)\n}\n\nfun example() {\n  fibonacci(6) shouldBe 8\n}\n")),(0,o.kt)("admonition",{title:"Memoization takes memory",type:"caution"},(0,o.kt)("p",{parentName:"admonition"},"If you define the memoized version of your function as a ",(0,o.kt)("inlineCode",{parentName:"p"},"val"),", as we've done\nabove, the cache is shared among ",(0,o.kt)("strong",{parentName:"p"},"all")," calls to your function. In the worst\ncase, this may result in memory which cannot be reclaimed throughout the whole\nexecution, so you should apply this technique carefully."),(0,o.kt)("p",{parentName:"admonition"},"There's some literature about ",(0,o.kt)("a",{parentName:"p",href:"https://otee.dev/2021/08/18/cache-replacement-policy.html"},"eviction policies for memoization"),",\nbut at the moment of writing memoize doesn't offer any type of control over the\ncached values. ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/sksamuel/aedile"},"Aedile")," is a Kotlin-first\ncaching library which you can use to manually tweak your memoization.")))}m.isMDXComponent=!0}}]);