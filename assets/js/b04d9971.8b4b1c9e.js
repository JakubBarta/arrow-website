"use strict";(self.webpackChunkarrow_website=self.webpackChunkarrow_website||[]).push([[3195],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>m});var a=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},d="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),d=p(n),u=i,m=d["".concat(l,".").concat(u)]||d[u]||h[u]||o;return n?a.createElement(m,r(r({ref:t},c),{},{components:n})):a.createElement(m,r({ref:t},c))}));function m(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,r=new Array(o);r[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[d]="string"==typeof e?e:i,r[1]=s;for(var p=2;p<o;p++)r[p]=n[p];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},76122:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>p});var a=n(87462),i=(n(67294),n(3905));const o={sidebar_position:5},r="Types and invariants",s={unversionedId:"ecosystem/analysis/types",id:"ecosystem/analysis/types",title:"Types and invariants",description:'Classes and interfaces (which we shall collectively refer to as "types") play a crucial role in organizing data in Kotlin. Arrow Analysis builds upon this idea, giving users the ability to attach Boolean expressions related to the data contained in a class. We call those invariants of the type, since the tool enforces those expressions to be true throughout the whole program.',source:"@site/content/docs/ecosystem/analysis/types.md",sourceDirName:"ecosystem/analysis",slug:"/ecosystem/analysis/types",permalink:"/ecosystem/analysis/types",draft:!1,editUrl:"https://github.com/arrow-kt/arrow-website/edit/main/content/docs/ecosystem/analysis/types.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5},sidebar:"ecosystemSidebar",previous:{title:"Mutability and loops",permalink:"/ecosystem/analysis/mutability"},next:{title:"Fields and wrappers",permalink:"/ecosystem/analysis/wrappers"}},l={},p=[{value:"Initializers with <code>pre</code> and <code>post</code>",id:"initializers-with-pre-and-post",level:2},{value:"Inheritance",id:"inheritance",level:2},{value:"Implicit pre and post-conditions",id:"implicit-pre-and-post-conditions",level:3},{value:"Post-condition or invariant?",id:"post-condition-or-invariant",level:3},{value:"Interfaces and abstract members",id:"interfaces-and-abstract-members",level:2},{value:"Enumerations",id:"enumerations",level:2}],c={toc:p},d="wrapper";function h(e){let{components:t,...n}=e;return(0,i.kt)(d,(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"types-and-invariants"},"Types and invariants"),(0,i.kt)("p",null,'Classes and interfaces (which we shall collectively refer to as "types") play a crucial role in organizing data in Kotlin. Arrow Analysis builds upon this idea, giving users the ability to attach Boolean expressions related to the data contained in a class. We call those ',(0,i.kt)("em",{parentName:"p"},"invariants")," of the type, since the tool enforces those expressions to be true throughout the whole program."),(0,i.kt)("p",null,"The easiest way to introduce invariants is using an ",(0,i.kt)("inlineCode",{parentName:"p"},"init")," block with calls to ",(0,i.kt)("inlineCode",{parentName:"p"},"require")," inside. Those initializers are run regardless of the constructor used to instantiate the class, so they provide the most compact way to declare the invariants."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"class Positive(val value: Int) {\n  init { require(value > 0) }\n}\n")),(0,i.kt)("p",null,"The invariant has dual roles with respect to the type. When you ",(0,i.kt)("em",{parentName:"p"},"instantiate")," the class, the invariant becomes a ",(0,i.kt)("em",{parentName:"p"},"pre-condition"),". In the example above, to create a ",(0,i.kt)("inlineCode",{parentName:"p"},"Positive")," object, the argument passed as ",(0,i.kt)("inlineCode",{parentName:"p"},"value")," must be greater than 0."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"val positiveExample = Positive(-1)\n")),(0,i.kt)("p",null,"In any other situation, using an instance of a type brings the invariant into the ",(0,i.kt)("em",{parentName:"p"},"environment"),". That means that the check can use that additonal information in its reasoning. For example, the analysis knows that from the fact that both ",(0,i.kt)("inlineCode",{parentName:"p"},"this")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"other")," are instances of ",(0,i.kt)("inlineCode",{parentName:"p"},"Positive"),", both ",(0,i.kt)("inlineCode",{parentName:"p"},"this.value")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"other.value")," are positive; hence its addition is positive and the call to the ",(0,i.kt)("inlineCode",{parentName:"p"},"Positive")," constructor is accepted."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"fun Positive.add(other: Positive) = Positive(this.value + other.value)\n")),(0,i.kt)("p",null,"In the above case we are using an extension method, but the same applies to functions declared within the class."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"class Positive(val value: Int) {\n  init { require(value > 0) }\n\n  operator fun plus(other: Positive) = Positive(this.value + other.value)\n}\n")),(0,i.kt)("p",null,"Remember that ",(0,i.kt)("inlineCode",{parentName:"p"},"init")," blocks apply to ",(0,i.kt)("em",{parentName:"p"},"every")," constructor. Arrow Analysis checks that when you delegate to another constructor, the invariants are still respected. For example, the following is rejected, since zero does not serve as a correct ",(0,i.kt)("inlineCode",{parentName:"p"},"value"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"class Positive(val value: Int) {\n  init { require(value > 0) }\n  \n  constructor() : this(0) { }\n}\n")),(0,i.kt)("p",null,"Types like ",(0,i.kt)("inlineCode",{parentName:"p"},"Positive")," above are a special case of ",(0,i.kt)("a",{parentName:"p",href:"../wrappers"},"wrappers"),", a way to attach additional invariants to already existing types (",(0,i.kt)("inlineCode",{parentName:"p"},"Int"),"in this case.)"),(0,i.kt)("h2",{id:"initializers-with-pre-and-post"},"Initializers with ",(0,i.kt)("inlineCode",{parentName:"h2"},"pre")," and ",(0,i.kt)("inlineCode",{parentName:"h2"},"post")),(0,i.kt)("p",null,"Whereas ",(0,i.kt)("inlineCode",{parentName:"p"},"init")," blocks are the preferred way to declare invariants, Arrow Analysis provides a more fine-grained approach which can be useful in some cases. Remember that an invariant plays two roles: you need them to be true at instantiation time, and you can count on them at usage time; you can decide for an invariant to have only the first role by using ",(0,i.kt)("inlineCode",{parentName:"p"},"pre")," in an initializer or constructor, and to have only the latter role by using ",(0,i.kt)("inlineCode",{parentName:"p"},"post"),". For example, the definition of ",(0,i.kt)("inlineCode",{parentName:"p"},"Positive")," above could be rewritten as:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},'import arrow.analysis.pre\nimport arrow.analysis.post\n\nclass Positive(val value: Int) {\n  init { \n    pre(value > 0) { "value must be positive" }\n    post({ this.value > 0 }) { "value is positive" }\n  }\n}\n')),(0,i.kt)("p",null,"The most common scenario for this split is when a secondary constructor enforces additional checks on input arguments. In that case ",(0,i.kt)("inlineCode",{parentName:"p"},"pre")," is used within the constructor."),(0,i.kt)("h2",{id:"inheritance"},"Inheritance"),(0,i.kt)("p",null,"Classes and interfaces do not live in a vacuum, in fact they often go into relationships with each other. This brings up the question of the relation of pre and post-conditions between parent and subclasses. To understand how Arrow Analysis approaches this problem, we need to look at the ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Liskov_substitution_principle"},"Liskov Substitution Principle"),", which roughly states:"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"If ",(0,i.kt)("inlineCode",{parentName:"p"},"B")," is a subclass of ",(0,i.kt)("inlineCode",{parentName:"p"},"A"),", then we should be able to use ",(0,i.kt)("inlineCode",{parentName:"p"},"B")," (and any of its methods) ",(0,i.kt)("strong",{parentName:"p"},"anywhere")," we use ",(0,i.kt)("inlineCode",{parentName:"p"},"A"))),(0,i.kt)("p",null,"This translates into the following two guidelines for the case in which ",(0,i.kt)("inlineCode",{parentName:"p"},"B")," overrides a method ",(0,i.kt)("inlineCode",{parentName:"p"},"m")," from class ",(0,i.kt)("inlineCode",{parentName:"p"},"A"),":"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"The pre-conditions on ",(0,i.kt)("inlineCode",{parentName:"li"},"B.m")," must be ",(0,i.kt)("strong",{parentName:"li"},"weaker")," than (or equivalent to) those of ",(0,i.kt)("inlineCode",{parentName:"li"},"A.m"),". This ensures that whenever we were calling ",(0,i.kt)("inlineCode",{parentName:"li"},"A.m")," we call ",(0,i.kt)("inlineCode",{parentName:"li"},"B.m")," instead."),(0,i.kt)("li",{parentName:"ol"},"The post-conditions offered by ",(0,i.kt)("inlineCode",{parentName:"li"},"B.m")," must be ",(0,i.kt)("strong",{parentName:"li"},"stronger")," than (or equivalent to) those of ",(0,i.kt)("inlineCode",{parentName:"li"},"A.m"),". This ensures that any reasoning that relies on ",(0,i.kt)("inlineCode",{parentName:"li"},"A.m")," still works when using ",(0,i.kt)("inlineCode",{parentName:"li"},"B.m"),".")),(0,i.kt)("p",null,"Let's look at a concrete example, and understand why it is rejected."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},'import arrow.analysis.post\n\nopen class A() {\n  open fun f(): Int = 2.post({ it > 0 }) { "greater than 0" }\n}\n\nclass B(): A() {\n  override fun f(): Int = 1.post({ it >= 0 }) { "non-negative" }\n}\n')),(0,i.kt)("p",null,"None of ",(0,i.kt)("inlineCode",{parentName:"p"},"A.f")," nor ",(0,i.kt)("inlineCode",{parentName:"p"},"B.f")," declare a pre-condition, so in particular they are equivalent. In the post-condition front, ",(0,i.kt)("inlineCode",{parentName:"p"},"A.f")," declares that the result must be ",(0,i.kt)("em",{parentName:"p"},"strictly")," greater than 0, whereas ",(0,i.kt)("inlineCode",{parentName:"p"},"B.f")," also allows ",(0,i.kt)("inlineCode",{parentName:"p"},"0")," in its post-condition. This means that the post-condition of ",(0,i.kt)("inlineCode",{parentName:"p"},"B.f")," is weaker than that of ",(0,i.kt)("inlineCode",{parentName:"p"},"A.f"),", and the code is rejected."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-plain"},"e: post-condition `greater than 0` from overridden member is not satisfied\n")),(0,i.kt)("h3",{id:"implicit-pre-and-post-conditions"},"Implicit pre and post-conditions"),(0,i.kt)("p",null,"Whenever a method in a type declares pre and post-conditions, but an overriden member does declare any, they are ",(0,i.kt)("em",{parentName:"p"},"implicitly")," inherited. This allows us to introduce a contract in a parent class or interface, and ensure that all their children satisfy that rule."),(0,i.kt)("p",null,"This slight modification of the example above is also rejected. In this case the post-condition ",(0,i.kt)("inlineCode",{parentName:"p"},"result > 0")," is implicitly inherited by ",(0,i.kt)("inlineCode",{parentName:"p"},"B.f"),". However, the result value computed in its body, ",(0,i.kt)("inlineCode",{parentName:"p"},"0"),", does not satisfy that post-condition."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},'import arrow.analysis.post\n\nopen class A() {\n  open fun f(): Int = 2.post({ it > 0 }) { "greater than 0" }\n}\n\nclass B(): A() {\n  override fun f(): Int = 0\n}\n')),(0,i.kt)("p",null,"There are exceptions to this implicit inheritance: initializer blocks and constructors. Meaning that invariants which hold in the parent class must be guaranteed in the subclasses, in the most extreme case by repeating those invariants."),(0,i.kt)("h3",{id:"post-condition-or-invariant"},"Post-condition or invariant?"),(0,i.kt)("p",null,"When designing a hierarchy of classes, we often need to decide whether we attach information about a property as an invariant of each class, or as a post-condition of the property. For example, this is another way in which we could have declared our ",(0,i.kt)("inlineCode",{parentName:"p"},"Positive")," class."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},'import arrow.analysis.post\n\nclass Positive(private n: Int) {\n  init { pre(n > 0) }\n  \n  val value: Int = n.post({ it > 0 }) { "value is positive" }\n}\n')),(0,i.kt)("p",null,"The differences between both ways are:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Invariants become available whenever we have an instance of that type, whereas post-conditions are only brought into consideration when we ",(0,i.kt)("em",{parentName:"li"},"use")," the property somewhere in the code. On that respect, invariants are slightly more powerful than post-conditions."),(0,i.kt)("li",{parentName:"ul"},"Post-conditions are ",(0,i.kt)("em",{parentName:"li"},"inherited"),", but invariants are not. As a consequence, if the property has some contract as part of the hierarchy, it should be declared as post-condition.")),(0,i.kt)("h2",{id:"interfaces-and-abstract-members"},"Interfaces and abstract members"),(0,i.kt)("p",null,"We have mentioned that by using pre and post-conditions we have enforce a particular contract on a hierarchy of types. This holds also for ",(0,i.kt)("inlineCode",{parentName:"p"},"interfaces"),", but we need to use a different way to attach those pre- and postconditions, since abstract members don't have a body where we can include ",(0,i.kt)("inlineCode",{parentName:"p"},"pre")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"post")," blocks. The solution is to use the ",(0,i.kt)("inlineCode",{parentName:"p"},"@Law")," annotation (you can learn more about it in the section about integration with 3rd-party libraries.)"),(0,i.kt)("p",null,"Following our example, this is how we would declare ",(0,i.kt)("inlineCode",{parentName:"p"},"A")," as an interface while keeping the promise of ",(0,i.kt)("inlineCode",{parentName:"p"},"f")," always returning a positive number. We add an additional member marked with the ",(0,i.kt)("inlineCode",{parentName:"p"},"@Law")," annotation, and whose body consists ",(0,i.kt)("strong",{parentName:"p"},"only")," of ",(0,i.kt)("inlineCode",{parentName:"p"},"pre")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"post")," blocks and a call to the function we want to decorate (the name is irrelevant, but we often use ",(0,i.kt)("inlineCode",{parentName:"p"},"method_Law")," or something similar.)"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},'import arrow.analysis.Law\nimport arrow.analysis.post\n\ninterface A {\n  fun f(): Int\n\n  @Law fun f_Law(): Int =\n    f().post({ it > 0 }) { "greater than 0" }\n}\n')),(0,i.kt)("h2",{id:"enumerations"},"Enumerations"),(0,i.kt)("p",null,"Everything we have described above holds without change for enumerations. However, note the special syntax you need to follow with ",(0,i.kt)("inlineCode",{parentName:"p"},"enum class")," in Kotlin: you first must introduce all the cases, then write a semicolon (",(0,i.kt)("inlineCode",{parentName:"p"},";"),"), and only then you are allowed to write an ",(0,i.kt)("inlineCode",{parentName:"p"},"init")," block."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},'enum class Color(val rgb: Int) {\n  RED(0xFF0000),\n  GREEN(0x00FF00),\n  BLUE(0x0000FF); // <-- the semicolon!\n\n  init {\n    require(rgb != 0) { "no zero color" }\n  }\n}\n')))}h.isMDXComponent=!0}}]);