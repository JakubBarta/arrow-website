"use strict";(self.webpackChunkarrow_website=self.webpackChunkarrow_website||[]).push([[3157],{3905:(e,n,t)=>{t.d(n,{Zo:()=>c,kt:()=>h});var a=t(67294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var l=a.createContext({}),p=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},c=function(e){var n=p(e.components);return a.createElement(l.Provider,{value:n},e.children)},m="mdxType",u={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},d=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),m=p(t),d=i,h=m["".concat(l,".").concat(d)]||m[d]||u[d]||r;return t?a.createElement(h,s(s({ref:n},c),{},{components:t})):a.createElement(h,s({ref:n},c))}));function h(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var r=t.length,s=new Array(r);s[0]=d;var o={};for(var l in n)hasOwnProperty.call(n,l)&&(o[l]=n[l]);o.originalType=e,o[m]="string"==typeof e?e:i,s[1]=o;for(var p=2;p<r;p++)s[p]=t[p];return a.createElement.apply(null,s)}return a.createElement.apply(null,t)}d.displayName="MDXCreateElement"},42005:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>u,frontMatter:()=>r,metadata:()=>o,toc:()=>p});var a=t(87462),i=(t(67294),t(3905));const r={sidebar_position:5},s="Prisms & Isos",o={unversionedId:"learn/immutable-data/prism-iso",id:"learn/immutable-data/prism-iso",title:"Prisms & Isos",description:"Prisms extend the capabilities of optics from merely inspecting or modifying",source:"@site/content/docs/learn/immutable-data/prism-iso.md",sourceDirName:"learn/immutable-data",slug:"/learn/immutable-data/prism-iso",permalink:"/learn/immutable-data/prism-iso",draft:!1,editUrl:"https://github.com/arrow-kt/arrow-website/edit/main/content/docs/learn/immutable-data/prism-iso.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5},sidebar:"learnSidebar",previous:{title:"Traversals",permalink:"/learn/immutable-data/traversal"},next:{title:"Reflection",permalink:"/learn/immutable-data/reflection"}},l={},p=[{value:"(Sealed) class hierarchies",id:"sealed-class-hierarchies",level:2},{value:"Constructing values",id:"constructing-values",level:3},{value:"Isomorphisms",id:"isomorphisms",level:2},{value:"Value classes",id:"value-classes",level:3}],c={toc:p},m="wrapper";function u(e){let{components:n,...t}=e;return(0,i.kt)(m,(0,a.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"prisms--isos"},"Prisms & Isos"),(0,i.kt)("p",null,"Prisms extend the capabilities of optics from merely inspecting or modifying\nvalues to ",(0,i.kt)("em",{parentName:"p"},"constructing")," them. This is very useful when using sealed hierarchies\nor value classes."),(0,i.kt)("admonition",{title:"In a rush?",type:"info"},(0,i.kt)("ul",{parentName:"admonition"},(0,i.kt)("li",{parentName:"ul"},"Prisms extend optionals to represent class hierarchies."),(0,i.kt)("li",{parentName:"ul"},"Isos extend prisms (and lenses) to represent lossless conversion between types.",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"One important case is given by value classes."))),(0,i.kt)("li",{parentName:"ul"},"To build a value use ",(0,i.kt)("inlineCode",{parentName:"li"},"reverseGet"),"."))),(0,i.kt)("h2",{id:"sealed-class-hierarchies"},"(Sealed) class hierarchies"),(0,i.kt)("p",null,"The following is an example of ",(0,i.kt)("inlineCode",{parentName:"p"},"User")," where\nwe have two options: a person or a company."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"import arrow.optics.*\n\n@optics sealed interface User {\n  companion object\n}\n@optics data class Person(val name: String, val age: Int): User {\n  companion object\n}\n@optics data class Company(val name: String, val country: String): User {\n  companion object\n}\n")),(0,i.kt)("p",null,"The Arrow Optics plug-in generates two optics within ",(0,i.kt)("inlineCode",{parentName:"p"},"User"),", namely\n",(0,i.kt)("inlineCode",{parentName:"p"},"User.person")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"User.company"),". These optics only focus on a value when\nit has the corresponding type. This is often used to modify a value only\nfor a specific type in the hierarchy, leaving the rest untouched. This is\nprecisely what happens in the function below:\n",(0,i.kt)("inlineCode",{parentName:"p"},"Person"),"s get their age incremented, but ",(0,i.kt)("inlineCode",{parentName:"p"},"Company"),"s remains unchanged."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"fun List<User>.happyBirthday() =\n  map { User.person.age.modify(it) { age -> age + 1 } }\n")),(0,i.kt)("p",null,"Several of the types in Arrow Core fit this pattern of sealed hierarchy, and\nArrow Optics contains optics matching those. One example is ",(0,i.kt)("inlineCode",{parentName:"p"},"Either"),", with\nthe corresponding ",(0,i.kt)("inlineCode",{parentName:"p"},"left")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"right"),"."),(0,i.kt)("h3",{id:"constructing-values"},"Constructing values"),(0,i.kt)("p",null,"The optics we're discussing in this section provide an added feature: they can\nbe used to ",(0,i.kt)("em",{parentName:"p"},"create")," new values in addition to inspecting or modifying existing\nones. Optionals with this power are called ",(0,i.kt)("strong",{parentName:"p"},"prisms"),", and this power is\navailable as the ",(0,i.kt)("inlineCode",{parentName:"p"},"reverseGet")," operation."),(0,i.kt)("p",null,"For example, we can build a ",(0,i.kt)("inlineCode",{parentName:"p"},"Left")," value using the corresponding prism\ninstead of the constructor."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"fun example() {\n  val x = Prism.left<Int, String>().reverseGet(5)\n  x shouldBe Either.Left(5)\n}\n")),(0,i.kt)("h2",{id:"isomorphisms"},"Isomorphisms"),(0,i.kt)("p",null,"Prisms allow you to construct values, but still the top of the hierarchy\nmay have different subclasses, so access still required as optional.\nFor example, you can construct an ",(0,i.kt)("inlineCode",{parentName:"p"},"Either")," from ",(0,i.kt)("inlineCode",{parentName:"p"},"Right"),", but when you\ninspect an ",(0,i.kt)("inlineCode",{parentName:"p"},"Either"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Left")," is also a possibility. There are some cases\nwhen the conversion between two types is lossless: we can go back and forth\nwithout any chance of failure on inspection. We say that there is an\n",(0,i.kt)("em",{parentName:"p"},"isomorphism")," between those types; for that reason the corresponding optic\nis called an ",(0,i.kt)("strong",{parentName:"p"},"iso"),"."),(0,i.kt)("p",null,"For example, we can move between ",(0,i.kt)("inlineCode",{parentName:"p"},"Option<String>")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Either<Unit, String>"),"\nwithout loss of information. We convert from ",(0,i.kt)("inlineCode",{parentName:"p"},"Some")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"Right"),", and from\n",(0,i.kt)("inlineCode",{parentName:"p"},"None")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"Left"),", and vice versa. There's no loss of information because\n",(0,i.kt)("inlineCode",{parentName:"p"},"Unit")," is an ",(0,i.kt)("inlineCode",{parentName:"p"},"object"),", so there's a single instance which may appear in the\n",(0,i.kt)("inlineCode",{parentName:"p"},"Left")," value."),(0,i.kt)("admonition",{title:"Iso = Prism + Lens",type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"You can see an iso as a prism where ",(0,i.kt)("inlineCode",{parentName:"p"},"get")," always succeeds,\nor as a lens which also supports the ",(0,i.kt)("inlineCode",{parentName:"p"},"reverseGet")," operation.")),(0,i.kt)("h3",{id:"value-classes"},"Value classes"),(0,i.kt)("p",null,"One important case in which lossless conversion is possible is given\nby ",(0,i.kt)("a",{parentName:"p",href:"https://kotlinlang.org/docs/inline-classes.html"},"value (or inline) classes"),",\nwhich wrap a single value as a distinct type. This kind of classes are\nvery useful to ",(0,i.kt)("a",{parentName:"p",href:"../../design/domain-modeling/"},"model your domain accurately"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"@optics data class Person(val name: String, val age: Age) {\n  companion object\n}\n\n@JvmInline @optics value class Age(val age: Int) {\n  companion object\n}\n")),(0,i.kt)("p",null,"Since isos are also lenses, you can still use the syntax from ",(0,i.kt)("a",{parentName:"p",href:"../lens/"},"the latter"),"\nto access the value contained in the class."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},'fun Person.happyBirthday(): Person =\n  Person.age.age.modify(this) { it + 1 }\n\nfun example() {\n  val p = Person("me", Age(29))\n  p.happyBirthday().age shouldBe Age(30)\n}\n')))}u.isMDXComponent=!0}}]);