"use strict";(self.webpackChunkarrow_website=self.webpackChunkarrow_website||[]).push([[4615],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>f});var r=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=r.createContext({}),p=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},c=function(e){var t=p(e.components);return r.createElement(l.Provider,{value:t},e.children)},m="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},y=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),m=p(n),y=o,f=m["".concat(l,".").concat(y)]||m[y]||u[y]||i;return n?r.createElement(f,a(a({ref:t},c),{},{components:n})):r.createElement(f,a({ref:t},c))}));function f(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,a=new Array(i);a[0]=y;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[m]="string"==typeof e?e:o,a[1]=s;for(var p=2;p<i;p++)a[p]=n[p];return r.createElement.apply(null,a)}return r.createElement.apply(null,n)}y.displayName="MDXCreateElement"},61641:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>p});var r=n(87462),o=(n(67294),n(3905));const i={title:"Type Proofs and FP for the Kotlin Type System",image:"https://img.youtube.com/vi/lK80dPcsNUg/hqdefault.jpg",category:"videos",tags:["meta","videos"],link:"https://www.youtube.com/watch?v=lK80dPcsNUg&t=353s",event:"Chicago Kotlin User Group Meetup"},a=void 0,s={permalink:"/community/blog/2020/05/27/type-proofs-fp-kotlin-talk",editUrl:"https://github.com/arrow-kt/arrow-website/edit/main/content/blog/2020-05-27-type-proofs-fp-kotlin-talk.md",source:"@site/content/blog/2020-05-27-type-proofs-fp-kotlin-talk.md",title:"Type Proofs and FP for the Kotlin Type System",description:"Type Proofs is a new compiler plugin built on Arrow Meta enabling new features in the Kotlin type system, such as Type Classes, Union Types, Type Refinements, and many other extensions that make Functional Programming easier in Kotlin.",date:"2020-05-27T00:00:00.000Z",formattedDate:"May 27, 2020",tags:[{label:"meta",permalink:"/community/blog/tags/meta"},{label:"videos",permalink:"/community/blog/tags/videos"}],readingTime:.495,hasTruncateMarker:!1,authors:[],frontMatter:{title:"Type Proofs and FP for the Kotlin Type System",image:"https://img.youtube.com/vi/lK80dPcsNUg/hqdefault.jpg",category:"videos",tags:["meta","videos"],link:"https://www.youtube.com/watch?v=lK80dPcsNUg&t=353s",event:"Chicago Kotlin User Group Meetup"},prevItem:{title:"Arrow Fx: Functional Domain Modeling with Kotlin",permalink:"/community/blog/2020/06/05/functional-domain-modeling-kotlin"},nextItem:{title:"Android architectures with Arrow Fx",permalink:"/community/blog/2020/05/06/android-architectures-arrow-fx"}},l={authorsImageUrls:[]},p=[],c={toc:p},m="wrapper";function u(e){let{components:t,...n}=e;return(0,o.kt)(m,(0,r.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"Type Proofs is a new compiler plugin built on Arrow Meta enabling new features in the Kotlin type system, such as Type Classes, Union Types, Type Refinements, and many other extensions that make Functional Programming easier in Kotlin."),(0,o.kt)("p",null,"Type Proofs propositions are expressed as extension functions that unlock new relationships between types ad-hoc whilst remaining fully compatible with subtype polymorphism and the existing inheritance type system."),(0,o.kt)("p",null,"This talk demonstrates some of the new features the Arrow team is introducing in Arrow at the type level and IDE and how others can benefit from them when building libraries and applications."))}u.isMDXComponent=!0}}]);