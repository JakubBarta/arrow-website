"use strict";(self.webpackChunkarrow_website=self.webpackChunkarrow_website||[]).push([[4149],{3905:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>h});var r=t(67294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var l=r.createContext({}),c=function(e){var n=r.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},p=function(e){var n=c(e.components);return r.createElement(l.Provider,{value:n},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},m=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),u=c(t),m=a,h=u["".concat(l,".").concat(m)]||u[m]||d[m]||o;return t?r.createElement(h,i(i({ref:n},p),{},{components:t})):r.createElement(h,i({ref:n},p))}));function h(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var o=t.length,i=new Array(o);i[0]=m;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s[u]="string"==typeof e?e:a,i[1]=s;for(var c=2;c<o;c++)i[c]=t[c];return r.createElement.apply(null,i)}return r.createElement.apply(null,t)}m.displayName="MDXCreateElement"},40869:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var r=t(87462),a=(t(67294),t(3905));const o={sidebar_position:2},i="Resource",s={unversionedId:"learn/coroutines/resource-safety",id:"learn/coroutines/resource-safety",title:"Resource",description:"Allocation and release of resources is not easy, especially when",source:"@site/content/docs/learn/coroutines/resource-safety.md",sourceDirName:"learn/coroutines",slug:"/learn/coroutines/resource-safety",permalink:"/learn/coroutines/resource-safety",draft:!1,editUrl:"https://github.com/arrow-kt/arrow-website/edit/main/content/docs/learn/coroutines/resource-safety.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"learnSidebar",previous:{title:"High-level concurrency",permalink:"/learn/coroutines/parallel"},next:{title:"Transactional memory (STM)",permalink:"/learn/coroutines/stm"}},l={},c=[{value:"Understanding the problem",id:"understanding-the-problem",level:2},{value:"Dealing with resources properly",id:"dealing-with-resources-properly",level:2},{value:"Using <code>resourceScope</code>",id:"using-resourcescope",level:3},{value:"Interfacing with Java",id:"interfacing-with-java",level:3},{value:"Using <code>Resource</code>",id:"using-resource",level:3},{value:"Integration with typed errors",id:"integration-with-typed-errors",level:2}],p={toc:c},u="wrapper";function d(e){let{components:n,...t}=e;return(0,a.kt)(u,(0,r.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"resource"},"Resource"),(0,a.kt)("p",null,"Allocation and release of resources is not easy, especially when\nwe have multiple resources that depend on each other. The Resource DSL\nadds the ability to ",(0,a.kt)("em",{parentName:"p"},"install")," resources and ensure proper finalization even\nin the face of exceptions and cancellations. Arrow's Resource co-operated\nwith Structured Concurrency and KotlinX Coroutines."),(0,a.kt)("admonition",{title:"Media resources",type:"info"},(0,a.kt)("ul",{parentName:"admonition"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://www.youtube.com/watch?v=zKrTBH8jqH4"},(0,a.kt)("em",{parentName:"a"},"Graceful Resource Handling"))," by Simon Vergauwen"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://kotlindevday.com/videos/grateful-shutdown-with-structured-concurrency-simon-vergauwen/"},(0,a.kt)("em",{parentName:"a"},"Graceful Shutdown with Structured Concurrency"))," by Simon Vergauwen"))),(0,a.kt)("admonition",{title:"Graceful Shutdowns",type:"note"},(0,a.kt)("p",{parentName:"admonition"},"Correct release of resources when the application is terminating is important\nin several scenarios. The Arrow community has you covered:\n",(0,a.kt)("a",{parentName:"p",href:"../../../ecosystem/suspendapp/"},"SuspendApp")," improves on\n",(0,a.kt)("inlineCode",{parentName:"p"},"Resource")," to gracefully deal with shutdown and termination.")),(0,a.kt)("h2",{id:"understanding-the-problem"},"Understanding the problem"),(0,a.kt)("p",null,"The following program is ",(0,a.kt)("strong",{parentName:"p"},"not")," safe because it is prone to leak ",(0,a.kt)("inlineCode",{parentName:"p"},"dataSource"),"\nand ",(0,a.kt)("inlineCode",{parentName:"p"},"userProcessor")," when an exception or cancellation signal occurs while using the service."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-kotlin"},'class UserProcessor {\n  fun start(): Unit = println("Creating UserProcessor")\n  fun shutdown(): Unit = println("Shutting down UserProcessor")\n}\n\nclass DataSource {\n  fun connect(): Unit = println("Connecting dataSource")\n  fun close(): Unit = println("Closed dataSource")\n}\n\nclass Service(val db: DataSource, val userProcessor: UserProcessor) {\n  suspend fun processData(): List<String> = \n    throw RuntimeException("I\'m going to leak resources by not closing them")\n}\n')),(0,a.kt)("p",null,"For example, the following application would leak resources."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-kotlin"},"suspend fun example() {\n  val userProcessor = UserProcessor().also { it.start() }\n  val dataSource = DataSource().also { it.connect() }\n  val service = Service(dataSource, userProcessor)\n\n  service.processData()\n\n  dataSource.close()\n  userProcessor.shutdown()\n}\n")),(0,a.kt)("p",null,"If we were using Kotlin JVM, we might rely on ",(0,a.kt)("inlineCode",{parentName:"p"},"Closeable")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"AutoCloseable")," and rewrite our code."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-kotlin"},"suspend fun example() {\n  UserProcessor().use { userProcessor ->\n    userProcessor.start()\n    DataSource().use { dataSource ->\n      dataSource.connect()\n      Service(dataSource, userProcessor).processData()\n    }\n  }\n}\n")),(0,a.kt)("p",null,"However, while we fixed the closing of ",(0,a.kt)("inlineCode",{parentName:"p"},"UserProcessor")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"DataSource"),", there are still issues with this code:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"It requires implementing ",(0,a.kt)("inlineCode",{parentName:"li"},"Closeable")," or ",(0,a.kt)("inlineCode",{parentName:"li"},"AutoCloseable"),", which is only possible for Kotlin JVM but not available for Multiplatform."),(0,a.kt)("li",{parentName:"ol"},"Requires implementing an interface or wrapping external types with something like ",(0,a.kt)("inlineCode",{parentName:"li"},"class CloseableOf<A>(val type: A): Closeable"),"."),(0,a.kt)("li",{parentName:"ol"},"Requires nesting of different resources in callback tree, not composable."),(0,a.kt)("li",{parentName:"ol"},"Enforces ",(0,a.kt)("inlineCode",{parentName:"li"},"close")," method name, renamed ",(0,a.kt)("inlineCode",{parentName:"li"},"UserProcessor#shutdown")," to ",(0,a.kt)("inlineCode",{parentName:"li"},"close")),(0,a.kt)("li",{parentName:"ol"},"Cannot run ",(0,a.kt)("inlineCode",{parentName:"li"},"suspend")," functions within ",(0,a.kt)("inlineCode",{parentName:"li"},"fun close(): Unit"),"."),(0,a.kt)("li",{parentName:"ol"},"No exit signal; we don't know if we exited successfully, with an error or cancellation.")),(0,a.kt)("p",null,"Resource solves these issues. The main idea is that each resource has three\nstages: 1\ufe0f\u20e3 acquiring the resource, 2\ufe0f\u20e3 using the resource, and 3\ufe0f\u20e3 releasing the\nresource. With ",(0,a.kt)("inlineCode",{parentName:"p"},"Resource"),", we bundle steps (1) and (3), and the implementation\nensures that everything works correctly, even in the event of exceptions or\ncancellations."),(0,a.kt)("h2",{id:"dealing-with-resources-properly"},"Dealing with resources properly"),(0,a.kt)("p",null,"You can use Arrow's Resource in two ways:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Using ",(0,a.kt)("inlineCode",{parentName:"li"},"resourceScope")," and functions with ",(0,a.kt)("inlineCode",{parentName:"li"},"ResourceScope")," as its receiver."),(0,a.kt)("li",{parentName:"ol"},"Wrapping the entire resource allocation and release as a ",(0,a.kt)("inlineCode",{parentName:"li"},"Resource<A>")," value,\nwhich we later ",(0,a.kt)("inlineCode",{parentName:"li"},"use")," in a larger block.")),(0,a.kt)("h3",{id:"using-resourcescope"},"Using ",(0,a.kt)("inlineCode",{parentName:"h3"},"resourceScope")),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"ResourceScope")," DSL allows you to ",(0,a.kt)("em",{parentName:"p"},"install")," resources and safely interact with them.\nIn fact, that's the only operation you need to learn about: ",(0,a.kt)("inlineCode",{parentName:"p"},"install")," takes both\nthe acquisition and release steps as arguments. The result of this function is\nwhatever was acquired, plus the promise of running the finalizer at the end of\nthe block."),(0,a.kt)("admonition",{type:"tip"},(0,a.kt)("p",{parentName:"admonition"},"The Resource DSL gives you enough flexibility to perform different actions\ndepending on how the execution finished: successful completion, exceptions,\nor cancellation. The second argument to the finalizer is of type ",(0,a.kt)("inlineCode",{parentName:"p"},"ExitCase"),"\nand represents the reason why the finalizer is run.")),(0,a.kt)("p",null,"The code below shows our ",(0,a.kt)("inlineCode",{parentName:"p"},"example")," rewritten to use ",(0,a.kt)("inlineCode",{parentName:"p"},"resourceScope"),". Note that\nwe acquire our ",(0,a.kt)("inlineCode",{parentName:"p"},"UserProcessor")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"DataSource")," in parallel, using the ",(0,a.kt)("a",{parentName:"p",href:"../parallel"},(0,a.kt)("inlineCode",{parentName:"a"},"parZip"),"\noperation in Arrow"),". This means that their ",(0,a.kt)("inlineCode",{parentName:"p"},"start")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"connect"),"\nmethods can run in parallel."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-kotlin"},"suspend fun ResourceScope.userProcessor(): UserProcessor =\n  install({ UserProcessor().also { it.start() } }) { p, _ -> p.shutdown() }\n\nsuspend fun ResourceScope.dataSource(): DataSource =\n  install({ DataSource().also { it.connect() } }) { ds, _ -> ds.close() }\n\nsuspend fun example(): Unit = resourceScope {\n  val service = parZip({ userProcessor() }, { dataSource() }) { userProcessor, ds ->\n    Service(ds, userProcessor)\n  }\n  val data = service.processData()\n  println(data)\n}\n")),(0,a.kt)("p",null,"The code above also showcases a very common pattern of resource acquisition:\nrunning the constructor, followed by calling some start method using Kotlin's\n",(0,a.kt)("inlineCode",{parentName:"p"},"also")," scope function."),(0,a.kt)("admonition",{type:"note"},(0,a.kt)("p",{parentName:"admonition"},"To achieve its behavior, ",(0,a.kt)("inlineCode",{parentName:"p"},"install")," invokes the ",(0,a.kt)("inlineCode",{parentName:"p"},"acquire")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"release")," step\nas ",(0,a.kt)("a",{parentName:"p",href:"https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-non-cancellable/"},"NonCancellable"),".\nIf a cancellation signal or an exception is received during ",(0,a.kt)("inlineCode",{parentName:"p"},"acquire"),", the\nresource is assumed to ",(0,a.kt)("strong",{parentName:"p"},"not")," have been acquired and thus will not trigger the\nrelease function; any composed resources that are already acquired are guaranteed\nto release as expected.")),(0,a.kt)("h3",{id:"interfacing-with-java"},"Interfacing with Java"),(0,a.kt)("p",null,"If you're running on the JVM, Arrow provides built-in integration with\n",(0,a.kt)("a",{parentName:"p",href:"https://docs.oracle.com/javase/8/docs/api/java/lang/AutoCloseable.html"},(0,a.kt)("inlineCode",{parentName:"a"},"AutoCloseable")),"\nin the form of the ",(0,a.kt)("a",{parentName:"p",href:"https://apidocs.arrow-kt.io/arrow-fx-coroutines/arrow.fx.coroutines/closeable.html"},(0,a.kt)("inlineCode",{parentName:"a"},"closeable"))," function."),(0,a.kt)("h3",{id:"using-resource"},"Using ",(0,a.kt)("inlineCode",{parentName:"h3"},"Resource")),(0,a.kt)("p",null,"The usage of ",(0,a.kt)("inlineCode",{parentName:"p"},"resource")," is very similar to ",(0,a.kt)("inlineCode",{parentName:"p"},"install"),". The main difference\nis that the result is a value of type ",(0,a.kt)("inlineCode",{parentName:"p"},"Resource<T>"),", where ",(0,a.kt)("inlineCode",{parentName:"p"},"T")," is the type of\nthe resource to acquire. But such a value doesn't run the acquisition step,\nit's simply a ",(0,a.kt)("em",{parentName:"p"},"recipe")," describing how that's done; to actually acquire the\nresource, you need to call ",(0,a.kt)("inlineCode",{parentName:"p"},".bind()")," inside a ",(0,a.kt)("inlineCode",{parentName:"p"},"resourceScope"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-kotlin"},'val userProcessor: Resource<UserProcessor> = resource({\n  UserProcessor().also { it.start() }\n}) { p, _ -> p.shutdown() }\n\nval dataSource: Resource<DataSource> = resource({\n  DataSource().also { it.connect() }\n}) { ds, exitCase ->\n  println("Releasing $ds with exit: $exitCase")\n  withContext(Dispatchers.IO) { ds.close() }\n}\n\nval service: Resource<Service> = resource {\n  Service(dataSource.bind(), userProcessor.bind())\n}\n\nsuspend fun example(): Unit = resourceScope {\n  val data = service.bind().processData()\n  println(data)\n}\n')),(0,a.kt)("admonition",{type:"info"},(0,a.kt)("p",{parentName:"admonition"},(0,a.kt)("em",{parentName:"p"},"Why provide two ways to accomplish the same goal?"),"\nAlthough ",(0,a.kt)("inlineCode",{parentName:"p"},"resourceScope")," provides nicer syntax in general, some usage patterns\nlike acquiring several resources become easier when the steps are saved in\nan actual class."),(0,a.kt)("p",{parentName:"admonition"},"The actual magic is that ",(0,a.kt)("inlineCode",{parentName:"p"},"Resource")," is nothing more than a type alias for\nparameter-less function using ",(0,a.kt)("inlineCode",{parentName:"p"},"ResourceScope"),","),(0,a.kt)("pre",{parentName:"admonition"},(0,a.kt)("code",{parentName:"pre",className:"language-kotlin"},"typealias Resource<A> = suspend ResourceScope.() -> A\n"))),(0,a.kt)("p",null,"Although the primary usage pattern is to give ",(0,a.kt)("inlineCode",{parentName:"p"},"resource")," the acquisition and\nrelease steps directly, there's another way to define a ",(0,a.kt)("inlineCode",{parentName:"p"},"Resource<T>"),".\nArrow provides a ",(0,a.kt)("inlineCode",{parentName:"p"},"resource")," for more complex scenarios that takes a block\nwith ",(0,a.kt)("inlineCode",{parentName:"p"},"ResourceScope")," as a receiver. That allows calling ",(0,a.kt)("inlineCode",{parentName:"p"},"install")," as required."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-kotlin"},"val userProcessor: Resource<UserProcessor> = resource {\n  val x: UserProcessor = install(\n    {  UserProcessor().also { it.start() } },\n    { processor, _ -> processor.shutdown() }\n  )\n  x\n}\n")),(0,a.kt)("h2",{id:"integration-with-typed-errors"},"Integration with typed errors"),(0,a.kt)("p",null,"Resource management cooperates with ",(0,a.kt)("a",{parentName:"p",href:"../../typed-errors"},"typed error builders"),".\nIt's important to be aware that the order in which we open the scopes\naffects the behavior. To be more concrete, let's consider the two possible\nnestings of ",(0,a.kt)("inlineCode",{parentName:"p"},"resourceScope")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"either"),"."),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"When ",(0,a.kt)("inlineCode",{parentName:"p"},"either")," is in the outermost position and ",(0,a.kt)("inlineCode",{parentName:"p"},"resourceScope")," is inside of it,\na bind that crosses the ",(0,a.kt)("inlineCode",{parentName:"p"},"resourceScope")," results in the release finalizer\nbeing called with ",(0,a.kt)("inlineCode",{parentName:"p"},"Cancelled"),"."),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-kotlin"},'either<String, Int> {\n  resourceScope {\n    val a = install({ }) { _, ex -> println("Closing A: $ex") }\n    raise("Boom!")\n  } // Closing A: ExitCase.Cancelled\n} // Either.Left(Boom!)\n'))),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"With reverse nesting order of ",(0,a.kt)("inlineCode",{parentName:"p"},"either")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"resourceScope"),', then resources\nare released with a normal state since nothing "failed."'),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-kotlin"},'resourceScope {\n  either<String, Int> {\n    val a = install({ }) { _,ex -> println("Closing A: $ex") }\n    raise("Boom!")\n  } // Either.Left(Boom!)\n} // Closing A: ExitCase.Completed\n')))),(0,a.kt)("p",null,"We remark that, in both cases, resources are correctly released. If you're\nfinalizer works in the same way for every possible ",(0,a.kt)("inlineCode",{parentName:"p"},"ExitCase"),", then there's no\nvisible difference between both. "),(0,a.kt)("admonition",{type:"info"},(0,a.kt)("p",{parentName:"admonition"},"If you want to know more, this ",(0,a.kt)("a",{parentName:"p",href:"https://kotlinlang.slack.com/archives/C5UPMM0A0/p1677093177834299"},"conversation"),"\nin the Kotlin Slack goes into more detail.")))}d.isMDXComponent=!0}}]);